{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Netty核心组件-ByteBuf","text":"JDK提供的Buffer类实在太难用，例如读写操作切换需要flip()，DirectByteBuffer使用起来不方便。因此Netty自己提供了一套缓冲区的ByteBuf类来方便的进行缓冲区操作，在功能上与NIO的ByteBuffer是相同的。 概述Netty提供的ByteBuf优点有如下： 它可以被用户自定义的缓冲区类型扩展 通过内置的符合缓冲区类型实现了透明的零拷贝 容量可以按需增长 在读和写这两种模式之间切换不需要调用 #flip() 方法 读和写使用了不同的索引 支持方法的链式调用 支持引用计数 支持池化 ByteBuf基础​ ByteBuf是Netty有关缓冲区类的抽象基类，所有的缓冲区类都是继承自该类，该类的大部分方法都是抽象的，ByteBuf对字节数组的操作比NIO的ByteBuffer方便、灵活的多。 读写模式ByteBuf中有如下重要属性(这几个属性没有在ByteBuf中给出而是在AbstractByteBuf中给出，但是ByteBuf中定义了获取这些属性的方法)： readerIndex：读索引 writerIndex：写索引 capacity：字节数组的当前容量 maxCapacity：字节数组的最大容量，当writerIndex超过capacity时，可以自动地扩容，每次为2*capacity，但是不能超过maxCapacity ByteBuf引入了readerIndex和writerIndex来将读操作和写操作分开进行索引，避免了NIO的ByteBuffer在读写切换时需要flip() 四个大小关系很简单：readerIndex &lt;= writerIndex &lt;= capacity &lt;= maxCapacity 。如下所示： 123456+-------------------+------------------+------------------+| discardable bytes | readable bytes | writable bytes || | (CONTENT) | |+-------------------+------------------+------------------+| | | |0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity &lt;= maxCapacity 图中主要有三段数据： Discardable bytes(可废弃数据段)：在写入后被读取了的数据，位于0~readerIndex之间。 readable bytes(可读取的数据段)：读取操作只到了readerIndex，readerIndex~writerIndex之间的数据写入了但没有读取过，所以是可读取的数据。 writable bytes(可写的数据段)：字节数组还没有被写满，在writerIndex~capacity之间的空间还可以再被写入数据。 此外还有两个属性： markReaderIndex：标记读的索引位置 markWriterIndex：标记写的索引位置 这两个mark属性与NIO中的ByteBuffer提供的mark标记一样。 读写操作ByteBuf中定义了很多与读写相关的方法： 123456789101112131415161718192021222324252627282930313233// Byte 1 字节public abstract byte getByte(int index);public abstract short getUnsignedByte(int index);public abstract ByteBuf setByte(int index, int value);public abstract byte readByte();public abstract short readUnsignedByte();public abstract ByteBuf writeByte(int value);// Int 4 字节public abstract int getInt(int index);public abstract int getIntLE(int index);public abstract long getUnsignedInt(int index);public abstract long getUnsignedIntLE(int index);public abstract ByteBuf setInt(int index, int value);public abstract ByteBuf setIntLE(int index, int value);public abstract int readInt();public abstract int readIntLE();public abstract long readUnsignedInt();public abstract long readUnsignedIntLE();public abstract ByteBuf writeInt(int value);public abstract ByteBuf writeIntLE(int value);// Byte 数组public abstract ByteBuf getBytes(int index, ByteBuf dst);public abstract ByteBuf getBytes(int index, ByteBuf dst, int length);public abstract ByteBuf setBytes(int index, ByteBuf src);public abstract ByteBuf setBytes(int index, ByteBuf src, int length);// Stringpublic abstract CharSequence getCharSequence(int index, int length, Charset charset);public abstract int setCharSequence(int index, CharSequence sequence, Charset charset);public abstract CharSequence readCharSequence(int length, Charset charset);public abstract int writeCharSequence(CharSequence sequence, Charset charset); 以上给出了部分典型的方法，可以看出，ByteBuf可以方便地读取/写入各种不同的基本数据类型，并且很多方法返回ByteBuf对象(本身)可以进行链式调用。 以上不同的方法对readerIndex和writerIndex的影响是不同的： #getXXX(index) 方法，读取指定位置的数据，不改变 readerIndex 索引。 #readXXX() 方法，读取 readerIndex 位置的数据，会改成 readerIndex 索引。 #setXXX(index, value) 方法，写入数据到指定位置，不改变 writeIndex 索引。 #writeXXX(value) 方法，写入数据到指定位置，会改变 writeIndex 索引。 释放操作1234public abstract ByteBuf discardReadBytes(); // 释放已读的字节空间public abstract ByteBuf discardSomeReadBytes(); // 释放部分已读的字节空间public abstract ByteBuf clear(); // 清空字节空间。实际是修改 readerIndex=writerIndex=0，标记清空。 discardReadBytes 释放所有的已读的空间，相当于把discardable段的数据都释放掉。 优点：达到重用废弃段的空间内存。 缺点：释放的方式，是通过复制可读段到 ByteBuf 的头部。所以，频繁释放会导致性能下降。 1234567891011121314151617// 释放前BEFORE discardReadBytes() +-------------------+------------------+------------------+ | discardable bytes | readable bytes | writable bytes | +-------------------+------------------+------------------+ | | | | 0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity===========================================================================// 释放后AFTER discardReadBytes() +------------------+--------------------------------------+ | readable bytes | writable bytes (got more space) | +------------------+--------------------------------------+ | | |readerIndex (0) &lt;= writerIndex (decreased) &lt;= capacity discardSomeReadBytes 释放部分空间，取决于具体子类的实现 clear 清空字节空间。实际是修改 readerIndex = writerIndex = 0 ，标记清空。 优点：通过标记来实现清空，避免置空 ByteBuf ，提升性能。 缺点：数据实际还存在，如果错误修改 writerIndex 时，会导致读到“脏”数据。 1234567891011121314151617// 释放前BEFORE clear() +-------------------+------------------+------------------+ | discardable bytes | readable bytes | writable bytes | +-------------------+------------------+------------------+ | | | | 0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity=========================================================================== // 释放后AFTER clear() +---------------------------------------------------------+ | writable bytes (got more space) | +---------------------------------------------------------+ | | 0 = readerIndex = writerIndex &lt;= capacity ByteBuf核心子类 按内存类型分： HeapByteBuf(堆内字节缓冲)：字节数组缓冲区位于JVM的堆区。特点是申请和释放效率较高，但是缺点与NIO的堆内缓冲区一样，在进行网络I/O操作时数据不能直接读/写到堆内缓冲区，需要先在内核空间建立一个缓冲区，把网络传输的数据写到内核空间的缓冲区后再拷贝到堆内的缓冲区，读写的性能有损耗。 DirectByteBuf(直接内存字节缓存)：字节数组的缓冲位于JVM的堆外空间(元空间)。特点是I/O读写效率高，因为该缓冲区建立在堆外，并且利用mmap的系统调用使得操作系统可以直接读写该缓冲区的数据，因此不需要进行像堆内字节缓冲那样的拷贝，性能更高。缺点是由于位于堆外内存，释放必须触发Full GC，而Full GC对性能的损耗比较大，需要合理使用。 堆内缓冲与堆外缓冲的细节在NIO中已经说明清楚，Netty的缓冲类也具备相同的特点，在此不详细赘述。 按是否建立对象池分： PooledByteBuf(具有对象池)：该字节数组缓冲区对象位于缓冲对象池内，释放时会被归还到对象池中得以重复利用，这样每次使用ByteBuf时就不需要重新去创建对象，经常创建ByteBuf会触发GC，尤其是DirectByteBuf会触发Full GC，造成性能损耗。 UnpooledByteBuf(不具有对象池)：单纯创建一个新的ByteBuf对象，使用完后就等待GC释放。由于对象池维护与创建比较麻烦，不需要大量创建缓冲区对象的地方推荐使用UnpooledByteBuf 按是否使用Unsafe分类： 由于Java不能够从直接操作底层，JDK提供了sun.misc.Unsafe对于底层的内存与线程直接操作，Unsafe被广泛用于JDK的官方源码中(并发包)，但是官方不推荐开发者使用，因为Unsafe对于内存直接进行操作，申请的内存不受JVM管理，需要手动释放内存，与C++的new/和delete类似，申请的空间如果不手动释放，便会造成内存泄漏。 使用Unsafe：由于Unsafe申请的缓冲区位于JVM内存区域的外部，完全不受JVM管控，即不会对GC造成影响，申请的空间在不使用时可以直接手动释放，因此具有更高的效率。 不使用Unasfe：申请的缓冲区位于JVM内存中(HeapByteBuf在堆内，DirectByteBuf在堆外元空间)，频繁的申请临时对象会造成GC压力，频繁的GC会损耗性能。 关于效率的说明： ​ Java中，几乎所有对象都是由JVM管理的，每次在使用new都会在堆空间创建一个对象后(不完全一定在堆空间，JVM逃逸分析允许局部小对象创建在栈区)，如果该局部对象失去了引用，并不会马上释放这个对象所占用的内存空间，而是等到内存占用到一定事件才会调用GC进行垃圾回收，对象的回收对于程序员而言时不可控的。因此，不适用Unsafe，在高并发的环境下，如果频繁的创建临时的ByteBuf（尤其是DirectByteBuf），会频繁的调用GC（DirectByteBuf调用的是Full GC），这无疑对性能有巨大的损失。而使用Unsafe就像写C/C++一样，可以控制缓冲区的生命周期，不用的时候马上释放而不用去麻烦GC，效率更高。 ​ Unsafe对于普通的开发者不要去使用，因为非常地不安全，一旦出问题就会造成JVM崩溃。Netty为我们封装好了Unsafe的缓冲区，我们不需要考虑Unsafe缓冲区的内存释放，Netty已经通过引用计数和内存泄漏检测来保证缓冲区的内存释放，我们可以放心使用。","link":"/2020/09/01/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ByteBuf/"},{"title":"Netty核心组件-NIO","text":"NIO（JDK1.4）模型是一种同步非阻塞IO，主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector（多路复用器）。 1 Buffer1.1 基本使用Buffer的本质就是一个存放数据内存块，可以看成一个容器对象(内部含有数组)，该对象提供了一系列方法，能让我们轻松的使用内存块(数组)，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。 JDK中Buffer的子类如下： 首先，Buffer都具有4个重要属性： 12345// Invariants: mark &lt;= position &lt;= limit &lt;= capacityprivate int mark = -1;private int position = 0;private int limit;private int capacity; Buffer分为读模式和写模式，一次读操作或写操作都可能会导致position后移(可能即为JDK提供了不同的方法，有读操作后position后移的方法，也有读操作后position不后移的方法)： Buffer的使用： 1234567891011121314151617public class LearnBuffer { public static void main(String[] args) { IntBuffer buffer = IntBuffer.allocate(5); // postion=0, capacity=5, limit=5, mark=-1 for (int i = 0; i &lt; buffer.capacity(); i++) { buffer.put(i*2); // 每次put后position属性+1 } buffer.flip(); // 将position重置到0 buffer.position(1); // 将position置为1 buffer.limit(3); // 将limit置为3 while (buffer.hasRemaining()){ System.out.println(buffer.get()); // 每次get()都会导致postion+1 } }} 1.2 HeapBuffer和DirectByteBuffer​ HeapBuffer被称为No-DirectBuffer，这一缓冲区创建在JVM内存的堆区中，受到JVM的内存管理，创建和释放都是由JVM操作的。上面通过allocate方法创建的Buffer就是HeapBuffer。 ​ 利用HeapBuffer读取数据的过程如下： ​ Java程序向操作系统发起read()的系统调用，操作系统让CPU启动DMA来将物理磁盘中的数据读取到内核地址空间中的缓冲区，然后再将缓冲区中的内容拷贝到用户地址空间的Buffer对象中。在这过程中发生了一次从内核地址空间到用户地址空间的拷贝。由于HeapBuffer需要经过一次拷贝，其与BIO的文件操作代价相同，效率相差不多，但下面介绍的DirectByteBuffer效率更高。 ​ 针对如上HeapBuffer的一次拷贝进行优化，DirectByteBuffer是创建在堆外内存区的，即不受JVM的内存管理机制所控制，那么为什么DirectByteBuffer可以减少这一次拷贝呢？ ​ 这要归功于mmap()的系统调用，这种方式的I/O原理就是将用户缓冲区（user buffer）的内存地址和内核缓冲区（kernel buffer）的内存地址做一个映射，也就是说系统将内核地址空间的缓冲区和用户地址空间的缓冲区映射物理内存上的相同位置，这样一来就可避免了从内核空间向地址空间的拷贝消耗。 在HeapBuffer中，内核地址空间的缓冲采用的就是DirectByteBuffer，然后再把DirectBuffer中的数据拷贝到HeapBuffer中。通过跟踪ByteBuffer的源码可以查看到其read()方法调用到了IOUtil的read()方法： 123456789101112131415161718192021static int read(FileDescriptor fd, ByteBuffer dst, long position, NativeDispatcher nd) throws IOException{ if (dst.isReadOnly()) throw new IllegalArgumentException(&quot;Read-only buffer&quot;); if (dst instanceof DirectBuffer) return readIntoNativeBuffer(fd, dst, position, nd); // Substitute a native buffer ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining()); // 获得一个临时的DirectBuffer try { int n = readIntoNativeBuffer(fd, bb, position, nd); // 使用native方法利用DirectBuffer进行读取 bb.flip(); if (n &gt; 0) dst.put(bb); // 将DirectBuffer读取到的数据放入到ByteBuffer中 return n; } finally { Util.offerFirstTemporaryDirectBuffer(bb); }} DirectBuffer可以通过ByteBuffer.allocateDirect(int len)来进行申请。 1ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024); // 申请出来为DirectByteBuffer对象 1.3 DirectBuffer详解说明 Java中申请的DirectBuffer存在的内存区域究竟是内核地址空间还是用户地址空间呢？ ​ DirectBuffer(以DirectByteBuffer为例)其实分为两部分： 12345 Java | native |DirectByteBuffer | malloc'd[ address ] -+-&gt; [ data ] | 一部分为Java的堆内对象，DirectByteBuffer没有byte数组，但是有一个long address的属性，该属性在Buffer类中有，官方注释说明只用于DirectBuffer才有效： 12345public abstract class Buffer { // Used only by direct buffers // NOTE: hoisted here for speed in JNI GetDirectBufferAddress long address; ​ 另一部分为利用c语言的malloc申请的字节数组，该数据就是缓冲区，该缓冲区是用C语言API申请的，属于该进程，位于用户地址空间，只不过操作系统该部分内存有读写的权利，不需要经过内核地址空间的拷贝。 ​ DirectBuffer的主要缓冲区属于堆外内存，其生命周期不完全被JVM管制，因此使用需要谨慎，必须使用Full GC才能进行回收，但是Full GC的性能损耗很大，因此合理使用DirectBuffer才能有更高的效率，Netty封装了DirectBuffer比DirectBuffer更好用。 为什么DirectBuffer要在堆外申请，不能申请在堆内或者直接使用HeapBuffer进行mmap内存映射吗？ ​ JVM并不是不能直接用java HeapBuffer或java byte[]直接做IO读写，但JVM在GC过程中会移动内存，JVM移动内存的操作对操作系统是不可见的，因此必须mark此段内存不能移动，从而影响GC效率，所有采用堆外内存更为合适。 ​ Java利用HeapBuffer进行IO操作时都会使用到临时的DirectByteBuffer缓冲区。 性能说明 ​ 对于文件的读写，使用FileChannel的read或write方法无论传入的是HeapBuffer还是DirectBuffer都是会创建一个临时的DirectBuffer，所以效率是相同的。想要有更高的性能使用MappedByteBuffer就不会进行内核空间到用户空间的拷贝了。 MappedByteBuffer使用： 1234567891011public static void main(String[] args) throws IOException { FileChannel inChannel = FileChannel.open(Paths.get(&quot;pom.xml&quot;), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(&quot;pom2.xml&quot;), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE); // 读取文件的缓冲空间 MappedByteBuffer mappedByteBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size()); outChannel.write(mappedByteBuffer); inChannel.close(); outChannel.close();} ​ 由于JDK没有提供直接将DirectBuffer写到文件中的方法，因此还是需要一次拷贝的。 普通NIO文件拷贝： 1234567891011public static void nioFileCopy() throws IOException { FileChannel inChannel = FileChannel.open(Paths.get(&quot;pom.xml&quot;), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(&quot;pom2.xml&quot;), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE); ByteBuffer buf = ByteBuffer.allocate((int) inChannel.size()); buf.flip(); outChannel.write(buf); inChannel.close(); outChannel.close();} ​ 相比MappedByyeBuffer多了一次拷贝。 2 ChannelNIO的通道类似于流，但有些区别如下： 通道可以同时进行读写，而流只能读或者只能写 通道可以实现异步读写数据 通道可以从缓冲读数据，也可以写数据到缓冲 JDK提供的Channel类型有很多，常用的有FileChannel(文件读写通道)、DatagramChannel(UDP数据传输通道)、ServerSocketChannel 和 SocketChannel (ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket，TCPS数据传输)。 FileChannel类： 用于对本地文件的读写操作，主要的方法有： 1234public int read(ByteBuffer dst) //从通道读取数据并放到缓冲区中public int write(ByteBuffer src) //把缓冲区的数据写到通道中public long transferFrom(ReadableByteChannel src, long position, long count) //从目标通道中复制数据到当前通道public long transferTo(long position, long count, WritableByteChannel target) //把数据从当前通道复制给目标通道 实例–使用FileChannel实现文本的拷贝 123456789101112131415161718192021222324252627public class LearnChannel { public static void main(String[] args) throws IOException { // 创建文件对象 File file = new File(&quot;/Users/zhanglei/java/IdeaProjects/netty/src/main/java/com/tomcode/nio/LearnChannel.java&quot;); File target = new File(&quot;j.txt&quot;); // 创建流对象 FileInputStream fileInputStream = new FileInputStream(file); FileOutputStream fileOutputStream = new FileOutputStream(target); // 获取channel，channel需要从流对象中获取，流对象中具有channel属性但是为空，当调用getChannel时会创建channel对象 FileChannel inputChannel = fileInputStream.getChannel(); FileChannel outputChannel = fileOutputStream.getChannel(); // 创建缓冲区 ByteBuffer buffer = ByteBuffer.allocate(512); // 把inputchannel中的数据写到buffer中然后把buffer写到outputchannel int len = -1; while((len = inputChannel.read(buffer)) != -1){ buffer.flip(); outputChannel.write(buffer); buffer.clear(); // 必须clear()，否则postion=limit无法再读入数据，每次len=0陷入死循环 } // 流对象关闭channel就会关闭 fileInputStream.close(); fileOutputStream.close(); }} 同样，我们可以使用transferFrom就可以直接完成拷贝而不需要使用缓冲区了(其实底层也是利用了缓冲区)。 1outputChannel.transferFrom(inputStream); 使用Channel和Buffer的注意事项 ByteBuffer 支持类型化的put 和 get, put放入的是什么数据类型，get就应该使用相应的数据类型来取出，否则可能有BufferUnderflow-Exception 异常。(putInt–getInt，putChar–getChar) NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进行修改，效率很高。 前面我们讲的读写操作，都是通过一个Buffer 完成的，NIO 还支持 通过多个Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering 3 SelectorSelector选择器，作用是用于管理多个Channel，使用Selector实现IO多路复用，通常一个线程有一个Selector，而一个Selector对应多个Channel负责I/O，其工作的主要步骤： (1) 在服务器启动时，创建ServerSocketChannel并利用SelectionKey register(Selector sel, int ops)方法注册到Selector中，每个channel在一个Selector中对应一个的SelectionKey。 (2) 在循环中调用Selector的int select()方法来判断是Selector中是否有Channel需要处理(返回值为需要处理的channel数量)，注意select()方法是阻塞的，想要非阻塞可以调用select(int timeout)或selectNow()。 (3) 每当一个客户端需要连接服务器时，Selector的select方法会返回1，此时表明有channel发生了事件需要处理，那么就通过Selector的selectKeys()方法获取到所有事件的SelectionKey，可以通过SelectionKey判断其对应的是否为ServerSocketChannel，如果是则调用其accept()方法(不会阻塞，因为已经判断出有客户端要连接)。 (4) 通过ServerSocketChannel的accept方法都能获取到一个SocketChannel，将这个SocketChannel注册到Selector中。 (5) 回到(2)的循环，去判断各个channel是否有事件发生，有的话通过SocketChannel和ServerSocketChannel分开处理，ServerSocketChannel有事件就获取SocketChannel注册到Selector，SocketChannel有时间就读写。 实例–使用Selector来实现服务端： server端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SelectorLearn { public static void main(String[] args) throws IOException { // 创建ServerSocketChannel ServerSocketChannel server = ServerSocketChannel.open(); server.socket().bind(new InetSocketAddress(8888)); // 创建Selector Selector selector = Selector.open(); // 设置Channel为非阻塞的 server.configureBlocking(false); // 将server注册到selector，为ACCEPT操作，ServerSocketChannel才为该方式 server.register(selector, SelectionKey.OP_ACCEPT); while (true) { if(selector.select(1000) == 0){ // 等待获取200ms，没有事件 System.out.println(&quot;1s没有事件&quot;); continue; } System.out.println(&quot;event!&quot;); // 获取并遍历有事件发生的SelectionKey Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator(); while(iterator.hasNext()){ SelectionKey key = iterator.next(); if(key.isAcceptable()){ // 证明是ServerSocketChannel，获取对应的SocketChannel SocketChannel socket = server.accept(); socket.configureBlocking(false); // 向selector注册socket，为读操作事件(因为建立连接不一定马上有数据传输) socket.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024)); } if(key.isReadable()){ // 证明是SocketChannel SocketChannel socket = (SocketChannel) key.channel(); ByteBuffer buf = (ByteBuffer) key.attachment(); socket.read(buf); String content = new String(buf.array()); System.out.println(&quot;收到:&quot; + content); } // 处理必须从集合中移除，否则会重复处理 iterator.remove(); } } }} 说明： 一个Selector可以注册多个Channel，也可以注册不同种类的Channel（SocketChannel/ServerSocketChannel），每个Channel在注册到某个Selector上时会生成一个SelectionKey对象，里面保存了Channel，Selector以后选择的就是SelectionKey对象，SelectionKey与Channel一一对应。 当调用了Selector的selectKeys方法后，如果此时ServerSocketChannel有多个连接请求，在调用accept后也只会连接一个，然后再循环时因为还有连接未处理则ServerSocketChannel还是有事件，接着就可以处理下一个连接。那么还未被accept的连接都会存储在操作系统的一个连接队列中等待应用程序处理。 Selector： 1234567selector.select(); //阻塞selector.select(1000); //阻塞1000毫秒，在1000毫秒后返回selector.wakeup(); //唤醒selectorselector.selectNow(); //不阻塞，立马返还selector.selectedKeys(); // 当前有事件发生的SelectionKeyselector.keys(); // selector中注册的所有SelectionKey SelectionKey： 123456789101112int OP_ACCEPT：有新的网络连接可以 accept，值为 16int OP_CONNECT：代表连接已经建立，值为 8int OP_READ：代表读操作，值为 1 int OP_WRITE：代表写操作，值为 4 public abstract Selector selector(); //得到与之关联的 Selector 对象public abstract SelectableChannel channel(); //得到与之关联的通道public final Object attachment(); //得到与之关联的共享数据public abstract SelectionKey interestOps(int ops); //设置或改变监听事件public final boolean isAcceptable(); //是否可以 acceptpublic final boolean isReadable(); //是否可以读public final boolean isWritable(); //是否可以写 ServerSocketChannel： ServerSocketChannel 在服务器端监听新的客户端 Socket 连接 12345public static ServerSocketChannel open(); // 得到一个 ServerSocketChannel 通道public final ServerSocketChannel bind(SocketAddress local); // 设置服务器端端口号public final SelectableChannel configureBlocking(boolean block); // 设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式public SocketChannel accept(); // 接受一个连接，返回代表这个连接的通道对象public final SelectionKey register(Selector sel, int ops); // 注册一个选择器并设置监听事件 SocketChannel： SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。 12345678public static SocketChannel open();//得到一个 SocketChannel 通道public final SelectableChannel configureBlocking(boolean block);//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式public boolean connect(SocketAddress remote);//连接服务器public boolean finishConnect();//如果上面的方法连接失败，接下来就要通过该方法完成连接操作public int write(ByteBuffer src);//往通道里写数据public int read(ByteBuffer dst);//从通道里读数据public final SelectionKey register(Selector sel, int ops, Object att);//注册一个选择器并设置监听事件，最后一个参数可以设置共享数据public final void close();//关闭通道","link":"/2020/08/31/NIO/"},{"title":"Netty核心组件-ChannelFuture","text":"Netty的特点就是异步非阻塞的网络框架，在Netty中，几乎所有的IO操作都是异步执行的，我们调用IO操作的方法后，方法会返回一个Future类型的对象(一般为ChannelFuture)，ChannelFuture继承于JDK的Future对象，对Future进行了扩充。 JDK中的Future​ 从JDK1.5开始官方提供了Callable和Future接口，通过这两个接口，可以使得父线程在子线程执行完后得到任务执行的结果。 ​ 当一个操作比较耗时，而后面将要执行的几个任务与这个操作的结果无关，此时我们可以考虑使用异步执行，这与前端js中的ajax是相同的原理。在执行该函数时，我们马上返回一个对象，将耗时的操作放在其他线程执行，这样我们在父线程中就可以进行其他的操作，真正的数据可以等到我们需要它的时候再从函数的返回对象中获取出来。 Callable与RunnableJDK的线程池中可以提交两种类型的接口，即Callable与Runnable。 ​ java.lang.Runnable是JDK早期提供的线程相关的类，当创建一个线程时或者想线程池中提交一个任务时，需要将Runnable接口的对象传递进去，那么在线程分到时间片时就会自动的调用Runnable中唯一的run方法，该方法没有返回值。 123public interface Runnable { public abstract void run();} ​ ​ 而java.util.concurrent.Callable是JDK后续提供的，它也是一个接口，同样向线程池中提交一个任务时，也可传递以个Callable对象(自己创建线程时不能传递Callable对象，因为Thread没有提供Callable的构造函数)，Callable接口有一个方法call()，在线程分配到时间片时，会自动调用call()方法，与Runnbale不同的是，call()方法是有返回值的。 123public interface Callable&lt;V&gt; { V call() throws Exception;} FutureJDK中实现异步操作需要Callable配合Future使用，Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。 12345678public interface Future&lt;V&gt; { boolean cancel(boolean mayInterruptIfRunning); // 取消任务 boolean isCancelled(); // 判断任务是否取消 boolean isDone(); // 任务是否完成 V get() throws InterruptedException, ExecutionException; // 阻塞获取任务的结果 V get(long timeout, TimeUnit unit) // 带超时的获取任务结果 throws InterruptedException, ExecutionException, TimeoutException;} 那么如何通过Callable与Future来实现异步操作呢？在JDK提供的线程池ExecutorService中我们可以看到submit方法有不同的重载版本 123&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task); 这意味着我们想线程池中提交一个Callable方法可以得到一个Future对象，在未来的某个地方我们可以调用Future对象的get()方法来获取到该任务返回的结果。 12345678910111213141516171819202122232425@Slf4jpublic class SchedulePool { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()*2); log.debug(&quot;submit other task&quot;); Future&lt;Integer&gt; hello = executorService.submit(() -&gt; { try { sleep(1500); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(&quot;hello&quot;); return 2; }); log.debug(&quot;main task start&quot;); Thread.sleep(1000); log.debug(&quot;main task end&quot;); Integer i = hello.get(); log.debug(&quot;{}&quot;,i); executorService.shutdown(); }} 输出： 1234510:35:57.249 com.zl.threadpool.SchedulePool [main] - submit other task10:35:57.284 com.zl.threadpool.SchedulePool [main] - main task start10:35:58.289 com.zl.threadpool.SchedulePool [main] - main task end10:35:58.789 com.zl.threadpool.SchedulePool [pool-1-thread-1] - hello10:35:58.789 com.zl.threadpool.SchedulePool [main] - 2 ​ 从打印结果我们可以看到提交任务后我们马上拿到一个Future对象(此时任务还未执行完返回)，我们接着执行了打印操作，然后通过Future对象的get方法阻塞获取了先前提交任务的返回结果，直到任务完成后才拿到了结果打印。 ​ 本来两个任务需要1s+1.5s=2.5s才能够完成，现在只需要1.5s就能够完成。 ​ 提交Runnable对象就无法拿到返回的结果，不过也会返回一个Future对象，可以用于判断任务是否完成，即调用Future的get方法返回的是null，但是可以通过Future的isDone方法判断run方法是否执行完成。 FutureTask​ 不通过线程池提交任务，想要通过Thread类来实现异步调用后返回结果可以使用FutureTask类，FutureTask类其实也是实现了Runable接口，和Runable创建方法类似，此外，FutureTask还实现了Future接口，可通过FutureTask获取执行结果。 ​ FutureTask的构造函数必须传入Callable对象，因此我们可以从FutureTask中get到Callable的执行结果。 123456789101112131415161718public class CreateThread_FutureTask { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() { @Override public Integer call() throws Exception { Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + &quot;执行了&quot;); return 1; } }); Thread thread = new Thread(task, &quot;thread1&quot;); thread.start(); Integer integer = task.get(); // 阻塞，等待task任务的返回结果 System.out.println(integer); // 打印1 }} Future的缺点只能用以下方式获取结果： V get()阻塞等待 轮询boolean isDone(); 有限等待V get(long timeout, TimeUnit unit) 执行状态只有两种： boolean isDone(); boolean isCancelled(); 问题： 接口中只有isDone()方法判断一个异步操作是否完成，但是对于完成的定义过于模糊，JDK文档指出正常终止、抛出异常、用户取消都会使isDone()方法返回真。在我们的使用中，我们极有可能是对这三种情况分别处理，而JDK这样的设计不能满足我们的需求。 对于一个异步操作，我们更关心的是这个异步操作触发或者结束后能否再执行一系列动作。比如说，我们浏览网页时点击一个按钮后实现用户登录。在javascript中，处理代码如下： 123$(&quot;#login&quot;).click(function(){ login(); }); Netty中的Future​ 鉴于JDK提供的Future对象的缺点，Netty对JDK的Future进行了扩展，同样也命名为Future，主要方法如下： 123456789101112131415// 异步操作完成且正常终止boolean isSuccess();// 异步操作是否可以取消boolean isCancellable();// 异步操作失败的原因Throwable cause();// 添加一个监听者，异步操作完成时回调，类比javascript的回调函数Future&lt;V&gt; addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);Future&lt;V&gt; removeListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);// 阻塞直到异步操作完成Future&lt;V&gt; await() throws InterruptedException;// 同上，但异步操作失败时抛出异常Future&lt;V&gt; sync() throws InterruptedException;// 非阻塞地返回异步结果，如果尚未完成返回nullV getNow(); 从Future对象中可以获取任务执行的状态： 未执行完成时，isDone返回false，其他的自然返回false。而当任务完成后，isDone为true，但是完成的状态可能是成功完成了，也可能是发生了异常，还可能是被取消对应于右边三个状态。 12345678910111213141516* +---------------------------+* | Completed successfully |* +---------------------------+* +----&gt; isDone() = true |* +--------------------------+ | | isSuccess() = true |* | Uncompleted | | +===========================+* +--------------------------+ | | Completed with failure |* | isDone() = false | | +---------------------------+* | isSuccess() = false |----+----&gt; isDone() = true |* | isCancelled() = false | | | cause() = non-null |* | cause() = null | | +===========================+* +--------------------------+ | | Completed by cancellation |* | +---------------------------+* +----&gt; isDone() = true |* | isCancelled() = true |* +---------------------------+ 在JDK中，我们从Future中获取的数据是从Callable接口的call方法返回值获取的，JDK的异步实现方式是Future+Callable。而在Netty中，并没有使用Callable接口，而是自己提供了Promise接口继承Future接口提供数据。 123456789101112public interface Promise&lt;V&gt; extends Future&lt;V&gt; { // 标记异步操作结果为成功，如果已被设置（不管成功还是失败）则抛出异常IllegalStateException Promise&lt;V&gt; setSuccess(V result); // 同上，只是结果已被设置时返回False boolean trySuccess(V result); // 设置失败 Promise&lt;V&gt; setFailure(Throwable cause); boolean tryFailure(Throwable cause); // 设置不可取消 boolean setUncancellable();} 需要注意的是，setSucess与setFailure只能被调用一次，任何一个方法被调用过了都不能再调用了，再次调用会抛出异常，两个方法会通知添加到其内部的Listener执行对应的行为。 GenericFutureListener GenericFutureListener是Future对象的监听者，在Future对象完成任务后，回调其中的operationComplete方法。 123456789public interface GenericFutureListener&lt;F extends Future&lt;?&gt;&gt; extends EventListener { /** * Invoked when the operation associated with the {@link Future} has been completed. * * @param future the source {@link Future} which called this callback */ void operationComplete(F future) throws Exception;} 关于Netty异步调用的部分类结构图如下: ​ AbstractFuture 该抽象类实现了两个get()方法，阻塞等待获取异步执行的结果，下面给出其中一个，另外一个是带超时的get。 123456789101112131415public abstract class AbstractFuture&lt;V&gt; implements Future&lt;V&gt; { @Override public V get() throws InterruptedException, ExecutionException { await(); // 阻塞等待唤醒 Throwable cause = cause(); // 获取是否有异常 if (cause == null) { return getNow(); // 无异常，直接返回结果，有可能还未执行完(被打断的情况) } if (cause instanceof CancellationException) { throw (CancellationException) cause; } throw new ExecutionException(cause); } ChannelFuture ChannelFuture主要添加了两个方法 123456public interface ChannelFuture extends Future&lt;Void&gt; { // 返回关联此Future对象的channel Channel channel(); // 该Future是否有返回数据 boolean isVoid(); DefaultPromise DefaultPromise实现了大多的Promise接口和Future接口的方法： 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic Promise&lt;V&gt; setSuccess(V result) { if (setSuccess0(result)) { // 设置任务执行成功，并将结果放入 notifyListeners(); // 通知监听者任务执行完成，做出相应动作 return this; } throw new IllegalStateException(&quot;complete already: &quot; + this);}@Overridepublic Promise&lt;V&gt; setFailure(Throwable cause) { if (setFailure0(cause)) { // 设置任务执行失败，并将原因放入 notifyListeners(); // 通知监听者任务完成，做出相应的动作 return this; } throw new IllegalStateException(&quot;complete already: &quot; + this, cause);}@Overridepublic boolean isSuccess() { Object result = this.result; // 执行结果 return result != null &amp;&amp; result != UNCANCELLABLE &amp;&amp; !(result instanceof CauseHolder);}@Overridepublic Promise&lt;V&gt; addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener) { checkNotNull(listener, &quot;listener&quot;); synchronized (this) { addListener0(listener); // 添加监听者 } if (isDone()) { notifyListeners(); // 如果任务是完成了的，就通知所有的Listener } return this;} 让我们看一下通知监听者的细节： 1234567891011121314151617181920212223private void notifyListeners() { EventExecutor executor = executor(); // 获取executor()执行线程，在构造函数中传入 if (executor.inEventLoop()) { // 判断当前线程是否为executor final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get(); final int stackDepth = threadLocals.futureListenerStackDepth(); if (stackDepth &lt; MAX_LISTENER_STACK_DEPTH) { threadLocals.setFutureListenerStackDepth(stackDepth + 1); try { notifyListenersNow(); // 通知执行operationComplete } finally { threadLocals.setFutureListenerStackDepth(stackDepth); } return; } } safeExecute(executor, new Runnable() { @Override public void run() { notifyListenersNow(); } });} 首先，获取到该类中保存的executor，即执行任务的线程，该executor一定是eventLoop中的线程。跟着使用executor.inEventLoop()判断当前线程是否是excutor线程，是的的话直接执行通知监听者，不是的话则使用excutor线程执行通知监听者operationComplete方法。 ChannelFuture的使用在服务端我们使用ChannelFuture： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HServer { public static void main(String[] args) throws InterruptedException { EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); ServerBootstrap bootstrap = new ServerBootstrap(); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.remove(1); try { bootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;http&quot;, new HttpServerCodec()); pipeline.addLast(&quot;httpA&quot;, new HttpObjectAggregator(5*1024*1024)); pipeline.addLast(&quot;myHandler&quot;, new SimpleChannelInboundHandler&lt;HttpObject&gt;() { @Override protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception { // 设置响应内容 ByteBuf content = Unpooled.copiedBuffer(&quot;hello，我是服务器&quot;, CharsetUtil.UTF_8); DefaultFullHttpResponse re = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content); re.headers().add(HttpHeaderNames.CONTENT_TYPE, &quot;text/plain;charset=utf-8&quot;) .add(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes()); // 写出响应 ChannelFuture channelFuture = ctx.write(re); // 添加写出后的监听器，写出成功后，即invoke后执行 channelFuture.addListener((future)-&gt;{ if(future.isSuccess()) { System.out.println(&quot;成功&quot;); } else { System.out.println(&quot;失败&quot;); } }); } }); } }); ChannelFuture sync = bootstrap.bind(8888).sync(); sync.channel().closeFuture().sync(); } finally { bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } }} 如上程序实现服务端可以接受Http请求然后回复客户端，调用ctx.write(re)方法不会马上马上把消息写出给客户端，而是放在缓冲中，等到缓冲区满了或者调用invoke()方法后才会写出。在后面添加的监听器需要在invoke真正写出后才会执行。 注意： 如果把ctx.write(re)变成ctx.writeAndFlush(re)，那么执行完ctx.writeAndFlush(re)数据就已经被写出了，那么执行addListener会马上执行回调。","link":"/2020/09/08/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ChannelFuture/"}],"tags":[{"name":"netty","slug":"netty","link":"/tags/netty/"}],"categories":[{"name":"Netty","slug":"Netty","link":"/categories/Netty/"}]}