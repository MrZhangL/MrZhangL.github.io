<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java并发-volatile - MrZhang</title><meta description="volatile在多线程编程中是使用非常之多的一个关键字，对内存的可见性与指令的有序性加以控制，它是保证多线程工作安全、可控的一把利器。"><meta property="og:type" content="blog"><meta property="og:title" content="Java并发-volatile"><meta property="og:url" content="http://example.com/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/"><meta property="og:site_name" content="MrZhang"><meta property="og:description" content="volatile在多线程编程中是使用非常之多的一个关键字，对内存的可见性与指令的有序性加以控制，它是保证多线程工作安全、可控的一把利器。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimjcjuy5ej31aw0roq4d.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimkufbolij31bi0j8ab2.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimw82ko5gj31b20kwq4o.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimnpthzacj30p40hcjs2.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimnp0funhj30mk0hiq3n.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimnrl5kbsj30pe0jqgmm.jpg"><meta property="og:image" content="https://gitee.com/leizz1/pictures/raw/master/null/image-20200817110211748.png"><meta property="og:image" content="https://gitee.com/leizz1/pictures/raw/master/null/image-20200817105800253.png"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimpit49sdj30dc03nmy5.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimsxuftzzj31qi084gn7.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimtm37awnj315g08g3z8.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimtnhbdd6j316a08a754.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimw46l9hfj31760rqdio.jpg"><meta property="article:published_time" content="2020-09-11T02:50:12.000Z"><meta property="article:modified_time" content="2020-09-11T10:40:09.959Z"><meta property="article:author" content="tomcode"><meta property="article:tag" content="多线程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gimjcjuy5ej31aw0roq4d.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/"},"headline":"MrZhang","image":["https://tva1.sinaimg.cn/large/007S8ZIlly1gimjcjuy5ej31aw0roq4d.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gimkufbolij31bi0j8ab2.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gimw82ko5gj31b20kwq4o.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gimnpthzacj30p40hcjs2.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gimnp0funhj30mk0hiq3n.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gimnrl5kbsj30pe0jqgmm.jpg","https://gitee.com/leizz1/pictures/raw/master/null/image-20200817110211748.png","https://gitee.com/leizz1/pictures/raw/master/null/image-20200817105800253.png","https://tva1.sinaimg.cn/large/007S8ZIlly1gimpit49sdj30dc03nmy5.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gimsxuftzzj31qi084gn7.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gimtm37awnj315g08g3z8.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gimtnhbdd6j316a08a754.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gimw46l9hfj31760rqdio.jpg"],"datePublished":"2020-09-11T02:50:12.000Z","dateModified":"2020-09-11T10:40:09.959Z","author":{"@type":"Person","name":"tomcode"},"description":"volatile在多线程编程中是使用非常之多的一个关键字，对内存的可见性与指令的有序性加以控制，它是保证多线程工作安全、可控的一把利器。"}</script><link rel="canonical" href="http://example.com/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/xcode.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-11T02:50:12.000Z" title="2020-09-11T02:50:12.000Z">2020-09-11</time>发表</span><span class="level-item"><time dateTime="2020-09-11T10:40:09.959Z" title="2020-09-11T10:40:09.959Z">2020-09-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></span><span class="level-item">42 分钟读完 (大约6247个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java并发-volatile</h1><div class="content"><p>volatile在多线程编程中是使用非常之多的一个关键字，对内存的可见性与指令的有序性加以控制，它是保证多线程工作安全、可控的一把利器。<a id="more"></a></p>
<h1 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h1><p>JMM 即 Java Memory Model，它在Java的层面定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存等。</p>
<p><strong>(1) 现代CPU与内存的主要架构</strong></p>
<p>既然JMM是对底层硬件的抽象，我们首先来看看现代CPU与内存的主要架构。现代CPU(以x86为例)大多为多核心CPU，如下图所示：</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimjcjuy5ej31aw0roq4d.jpg" alt="image-20200911111028676" style="zoom: 50%;" />

<ul>
<li>CPU具有L1、L2、L3级的缓存，其中L1和L2级缓存是在每个核心中都存在的，而L3级缓存则是一个CPU所有核心共享的.</li>
<li>缓存的主要功能是将主内存的数据加载进来供计算单元使用，这样在一些数据需要多次使用时不需要每次都从主存中加载，执行效率更高。</li>
<li>对于不同CPU的L1和L2级缓存以公有的L3缓存与主内存，它们之间存在着缓存一致性协议（例如MESI，Intel架构下的缓存一致性协议），所以它们之间的数据是同步的，即如果存储在Core-1的L1缓存中的某个数据发生了变化，如果该数据在Core-2的L2级缓存中存在，那么L2中的该数据就会失效，需要重新从主内存中加载。</li>
<li>但是缓存一致性协议对性能有较大的的损耗，因此CPU的设计者在每个CPU的核心上又添加了各种缓存Buffer（例如Load Buffer、Store Buffer等），这些Buffer与其他的缓存或内存是没有一致性协议的，因此可能存在一个数据在Buffer中被修改而其他的核心都无法感知到。</li>
</ul>
<p><strong>(2) 操作系统层面的内存模型</strong></p>
<p>对于操作系统而言，既然L1、L2、L3缓存与主内存之间都是有一致性协议，那么统一看待即可，然后将每个核心看成独立的逻辑CPU，每个CPU都有自己独立的缓存（对应于Buffer），这些缓存之间没有一致性协议。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimkufbolij31bi0j8ab2.jpg" alt="image-20200911120215079" style="zoom: 50%;" />



<p><strong>(3) Java内存模型</strong></p>
<p>在Java的层面，是没有办法指定某个任务被哪个CPU所执行，只能指定某个线程来执行任务，结合JVM对内存的划分，因此可以抽象为下面的模型：</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimw82ko5gj31b20kwq4o.jpg" alt="image-20200911121919580" style="zoom:50%;" />

<ul>
<li>所有的变量都存储在主内存中(虚拟机内存的一部分)，对于所有线程都是共享的。</li>
<li>每条线程都有自己的工作内存(对应于CPU的高速缓存)，<strong>工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量</strong>。</li>
<li>线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成。</li>
</ul>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>volatile关键字并不能起到保证原子性的作用，只有在一种情况下，volatile会对原子性起到作用，那就是64位的long&amp;double类型数据的写入，我们考虑如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>以上对long类型的a变量读取与写入如果不加锁，在多线程环境下可能是有危险的，因为JVM规范没有规定对long&amp;double类型数据的操作是原子的，所以对double&amp;long类型操作的原子性取决于JVM实现，例如可能对于32位处理器而言，有些JVM的实现写入一个double类型的数据需要两步，那么会造成数据只写了一半就被读走了，或者写了一半又写了。用volatile修饰a变量可以解决这一问题，因为JVM虚拟机规范规定对volatile修饰的long和double操作必须是原子的。</p>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><h2 id="无法退出循环"><a href="#无法退出循环" class="headerlink" title="无法退出循环"></a>无法退出循环</h2><p>对于可见性，我们先来看下面一种情况：main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序在主线程中将run设置为false后t线程仍然无法停下来的现象，其主要原因是JVM的JIT即时编译器对循环进行了优化。将run变量从主存中拷贝了一份到线程的cpu缓存中，造成run在主线程中被修改了而t1线程不知道的情况。分析过程：</p>
<p>(1) 初始状态，t 线程刚开始从主内存读取了 run 的值到工作内存。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimnpthzacj30p40hcjs2.jpg" alt="image-20200911134137837" style="zoom:50%;" />



<p>(2) 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimnp0funhj30mk0hiq3n.jpg" alt="image-20200911134050709" style="zoom:50%;" />

<p>(3) 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimnrl5kbsj30pe0jqgmm.jpg" alt="image-20200911134319468" style="zoom:50%;" /></p>
<h2 id="解决可见性的办法"><a href="#解决可见性的办法" class="headerlink" title="解决可见性的办法"></a>解决可见性的办法</h2><p><strong>(1) volatile</strong></p>
<p>使用volatile关键字修饰变量，<code>它可以用来修饰成员变量和静态成员变量(不能修饰局部变量)</code>，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。</p>
<p>将run变量用volatile修饰后，t线程每次都是从主存中读取run变量，当主线程修改run变量后，t线程就可以结束。</p>
<p><strong>原理：</strong></p>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存Buffer后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行<code>写操作</code>，JVM就会<strong>向处理器发送一条Lock前缀的指令</strong>，将这个变量所在**缓存的数据写回到系统内(主存)**。</p>
<p>就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，被volatile修饰的数据就会实现<strong>缓存一致性</strong>协议，<strong>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期</strong>了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>因此volatile在保证可见性上完成了如下工作：</p>
<ol>
<li>Lock前缀的指令会引起处理器缓存写回内存(不仅volatile修饰的变量，缓存中所有的拷贝变量都会写回主存)；</li>
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存失效；</li>
<li>当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值(同样，是对所有的拷贝变量都刷新)。</li>
</ol>
<p>这样就能保证每个线程都能获取到volatile修饰的变量的最新值，其实不仅仅是对volatile变量，对于volatile修饰变量写操作之前的变量的写操作同样会被刷新到主存中。</p>
<p><strong>(2) synchronized/ReentrantLock</strong></p>
<p>使用synchronized/ReentrantLock上锁后，上锁的代码块中，变量都是从主存中取的，JVM不会使用JIT将run拷贝到高速缓存中，因此，也能够保证变量的可见性。</p>
<h2 id="volatile对属性对象的可见性"><a href="#volatile对属性对象的可见性" class="headerlink" title="volatile对属性对象的可见性"></a>volatile对属性对象的可见性</h2><p>​    由前面的讨论我们可以知道，volatile修饰的成员变量具有可见性，但是上述我们只讨论了成员变量为基本数据类型，现在我们来讨论当<code>成员变量为对象引用时</code>的可见性问题，首先定义两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWrapper</span> </span>&#123;</span><br><span class="line">    Task task = <span class="keyword">new</span> Task();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task.ending = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> task.ending;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task = <span class="keyword">new</span> Task();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ending = <span class="keyword">false</span>;</span><br><span class="line">    String name = <span class="string">&quot;da&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(1) 改变引用的值</strong></p>
<p>如果我们改变引用指向的对象(引用值发送变化)，那么很容易知道该变化是对所有线程可见的，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> TaskWrapper tsk = <span class="keyword">new</span> TaskWrapper();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Volatile vol = <span class="keyword">new</span> Volatile();</span><br><span class="line">        vol.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Task bk = tsk.task;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (tsk.task == bk) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;任务结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        tsk.change();</span><br><span class="line">        log.debug(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">37</span>:<span class="number">07</span>.<span class="number">042</span> com.zl.Visible.Volatile [t1] - 任务开始</span><br><span class="line"><span class="number">10</span>:<span class="number">37</span>:<span class="number">08.036</span> com.zl.Visible.Volatile [main] - change</span><br><span class="line"><span class="number">10</span>:<span class="number">37</span>:<span class="number">08.036</span> com.zl.Visible.Volatile [t1] - 任务结束</span><br></pre></td></tr></table></figure>

<p>​    如何tsk没有用volatile修饰，则t1线程无法感知到tsk的task引用发送变化，则任务无法马上结束。</p>
<p><strong>(2) 改变引用对象的非volatile属性</strong></p>
<p>​    volatile可以保证被修饰变量的可见性，但是如果被volatile修饰的引用的对象的属性发生了变化，例如上面程序中的TaskWrapper中的task引用，引用地址发送变化是可见的，但是task引用的对象的ending属性发生改变是否是可见的呢，注意ending、task引用均未被volatile修饰。我们测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> TaskWrapper tsk = <span class="keyword">new</span> TaskWrapper();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Volatile vol = <span class="keyword">new</span> Volatile();</span><br><span class="line">        vol.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Task bk = tsk.task;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;任务开始&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!tsk.isEnding()) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;任务结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        tsk.end();</span><br><span class="line">        log.debug(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">49</span>:<span class="number">21.617</span> com.zl.Visible.Volatile [t1] - 任务开始</span><br><span class="line"><span class="number">10</span>:<span class="number">49</span>:<span class="number">22.602</span> com.zl.Visible.Volatile [main] - change</span><br><span class="line"><span class="number">10</span>:<span class="number">49</span>:<span class="number">22.602</span> com.zl.Visible.Volatile [t1] - 任务结束</span><br></pre></td></tr></table></figure>

<p>我们从结果可以看到，task引用对象发生的改变仍然是可见的，如果TaskWrapper tsk未用volatile修饰则程序不会结束。不过这一结论我无法肯定，因为在JDK提供的ConcurrentHashMap中，对链表数组使用了volatile修饰，但是对链表节点的属性也使用了volatile修饰。    </p>
<img src="https://gitee.com/leizz1/pictures/raw/master/null/image-20200817110211748.png" alt="image-20200817110211748" style="zoom:80%;" />

<img src="https://gitee.com/leizz1/pictures/raw/master/null/image-20200817105800253.png" alt="image-20200817105800253" style="zoom:80%;" />

<p>因此在遇到这样的情况时，为了保险起见，还是<code>都加上volatile修饰</code>比较保险。</p>
<h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p>由于现代CPU在执行指令时都采用流水线工作模式，会造成指令交错的问题。首先来了解什么是流水线工作。</p>
<h2 id="流水线工作模式"><a href="#流水线工作模式" class="headerlink" title="流水线工作模式"></a>流水线工作模式</h2><p>所有的程序最终都会被翻译成机器指令(二进制)，从而被cpu所执行。而cpu执行每条指令又分为几个小步骤，例如Intel的i486处理器分为五个步骤：取指(Fetch)，译码(D1, main decode)，转址(D2, translate)，执行(EX, execute)，写回(WB)，因此被称为5级流水线。</p>
<p>cpu完成这些动作都分别使用一个硬件单元或寄存器，为了提供指令的并行度，例如在对第一条指令取指后马上可以对第二条指令取值，而此时第一条指令可能进入了译码阶段。这样一来可以不用等到第一条指令执行结束第二条指令才开始取指，虽然执行单条指令的速度并不会变快，但是单位时间内执行的指令数变多。</p>
<p>流水线工作模式如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimpit49sdj30dc03nmy5.jpg" alt="img"></p>
<p>流水线工作模式虽然不能缩短单条指令的执行时间，能够极大的提高指令执行的吞吐量，但是并不是所有情况下都能这么完美地进行流水线工作。对于下面的指令代码，它们的功能是将两个变量的内容进行交换，就不能完美地按照流水线式工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XOR a, b</span><br><span class="line">XOR b, a</span><br><span class="line">XOR a, b</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步是第一条指令进入取指阶段；</li>
<li>第二步第一条指令进入译码阶段，同时第二条指令进入取指阶段；</li>
<li>第三步第一条指令进入转址阶段，第二条指令进入译码阶段，第三条指令进入取指阶段。</li>
<li>第四步会出现问题，第一条指令会进入执行阶段，而其他指令却不能继续向前移动。第二条 xor 指令需要第一条 xor 指令计算的结果a，但是直到第一条指令执行完成才会写回。所以<strong>流水线的其他指令就会在当前流水级等待直到第一条指令的执行和写回阶段完成</strong>。第二条指令会等待第一条指令完成才能进入流水线下一级，同样第三条指令也要等待第二条指令完成。</li>
</ul>
<p>这个现象被称为流水线阻塞或者流水线气泡，即后面的指令必须等到前面的指令执行完才能继续执行步骤，而不是像之前那样完美地实现流水线式的工作模式，因此<strong>CPU</strong>可能会<strong>对指令进行重排序</strong>，如果重新排序后的指令对最后结果没有影响，那么会将不相干的几条指令连续排列以达到完美地流水线式的工作，CPU级别的重排序我们暂先不关注，主要是JVM对指令重排序也会基于上面的原因进行优化。</p>
<h2 id="JVM指令重排"><a href="#JVM指令重排" class="headerlink" title="JVM指令重排"></a>JVM指令重排</h2><p>大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。通过乱序执行的技术，处理器可以大大提高执行效率。除了处理器，常见的Java运行时环境的JIT编译器也会做指令重排序操作，即生成的机器指令与字节码指令顺序不一致。</p>
<p>如果前后指令有数据依赖性，那么指令顺序是不会交换的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名称       代码示例         说明  </span><br><span class="line">写后读     a = <span class="number">1</span>;b = a;    写一个变量之后，再读这个位置。  </span><br><span class="line">写后写     a = <span class="number">1</span>;a = <span class="number">2</span>;    写一个变量之后，再写这个变量。  </span><br><span class="line">读后写     a = b;b = <span class="number">1</span>;    读一个变量之后，再写这个变量。</span><br></pre></td></tr></table></figure>

<p>每组指令中都有写操作，这个写操作的位置是不允许变化的，否则将带来不一样的执行结果。<br>编译器将不会对存在数据依赖性的程序指令进行重排，这里的<strong>依赖性仅仅指单线程情况下的数据依赖性</strong>；多线程并发情况下，此规则将失效。</p>
<p><strong>多线程下指令重排引发的问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        a = <span class="number">1</span>;                     <span class="comment">// 1  </span></span><br><span class="line">        flag = <span class="keyword">true</span>;               <span class="comment">// 2  </span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">// 3  </span></span><br><span class="line">            <span class="keyword">int</span> i =  a * a;        <span class="comment">// 4  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程环境下，当使用同样的该对象时，由于语句1和语句2没有数据依赖关系，JVM可能将两者进行重排序，即先执行语句2再执行语句1，那么就会可能出现flag已经为true了但是a仍然为0。当先执行完语句2后，时间片用完而执行reader()函数，那么就会出现i为0的情况。</p>
<h2 id="volatile禁止指令重排"><a href="#volatile禁止指令重排" class="headerlink" title="volatile禁止指令重排"></a>volatile禁止指令重排</h2><p>volatile关键字可以禁止指令重排，在如上的例子中，我们将flag用volatile修饰，那么就可以防止语句1和语句2的重排序，保证先执行语句1再执行语句2。</p>
<p>volatile禁止重排序是通过<code>内存屏障</code>的方式来实现的。为了进制<strong>编译器重排序</strong>和<strong>CPU重排序</strong>，在编译器和CPU层面都有对应的指令，也就是<code>内存屏障</code>。编译器的内存屏障是告诉编译器不要进行进行指令重排序，当编译完成之后，内存屏障就消失了，CPU并不会感知到编译器中的内存屏障，但是这不是我们需要关注的，我们关注于Java提供的volatile能够保证什么样的有序性。</p>
<p>在CPU层面有4种内存屏障（Load表示读，Store表示写）：</p>
<ul>
<li>LoadLoad：禁止读操作与读操作指令发生重排序，即如果指令是load1 <code>LoadLoad</code> load2，那么一定会保证load1不会重排到load2之后。</li>
<li>StoreStore：禁止写操作与写操作指令发生重排序，即如果指令是store1 <code>StoreStore</code> store2，那么一定会保证store1不会重排到store2之后</li>
<li>LoadStore：禁止读操作与写操作指令发生重排序，即如果指令是load <code>LoadStore</code> store，那么一定会保证load不会重排到store之后</li>
<li>StoreLoad：禁止写操作和读操作指令发生重排序，即如果指令是store <code>StoreLoad</code> load，那么一定会保证store不会重排到load之后</li>
</ul>
<p>如上的禁止重排并不只是指前后一条指令，例如LoadLoad可以禁止其后面的所有写操作重排到前面。</p>
<p>volatile的底层原理是建立如下内存屏障：</p>
<ul>
<li>在volatile变量的写操作前加入一个StoreStore内存屏障，保证volatile变量的写操作不会和之前的写操作发生重排序。</li>
<li>在volatile变量的写操作后面加入一个StoreLoad内存屏障，保证volatile变量的写操作不会和后续的读操作发生重排序。</li>
<li>在volatile变量的读操作后加入一个LoadLoad+LoadStore内存屏障，保证volatile变量的读操作不会和后续的写操作或读操作发生重排序。</li>
</ul>
<p>由于这种重排序的情况很难测试出来，因此下面我们使用JCStress压测工具来进行压测以验证指令重排以及volatile的作用。关于JCStress工具的配置参考博客<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b4c80184faca">jcstress 高并发测试框架使用教程</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id=&#123;&quot;1&quot;, &quot;2&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;0&quot;&#125;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;wrong&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Seq</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            r.r1 = a*a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过压力测试有如下结果显示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimsxuftzzj31qi084gn7.jpg" alt="image-20200911164220013"></p>
<p>该结果表示，经过压力测试有15944211个线程结果为1，有31192483个线程结果为2，而又256个线程的结果为0，这表示当flag为true时，a仍然为0，这是指令重排序导致的结果，<code>flag=true</code>的操作被重排到<code>a=1</code>之前了。</p>
<p>当我们给flag加上<code>volatile</code>修饰，再进行压测则不会出现上述的情况。在这里我个人还有一点疑问，那就是如果用volatile修饰a变量，那么会出现因重排序错误的情况吗？因为volatile只是在写操作之前加入了LoadLoad屏障，而没有在之后加入LoadLoad屏障，那么<code>a=1</code>和<code>flag=true</code>会不会发生重排序。经过压测是不会出现的，我想这个内存屏障应该是跟着变量走的，也就是不会出现：</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimtm37awnj315g08g3z8.jpg" alt="image-20200911170538204" style="zoom:50%;" />

<p>在这里假设load2操作就是针对volatile变量的，如果Load2要和Load3重排那应该也会变成</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimtnhbdd6j316a08a754.jpg" alt="image-20200911170658683" style="zoom:50%;" />

<p>这是不符合LoadLoad内存屏障的，因为Load3原本位于Load2之后，重排以后位于LoadLoad内存屏障之前。所以，在volatile变量之前加入LoadLoad内存屏障也可防止volatile写操作与后续的写操作发生重排。</p>
<h2 id="单例懒加载设计模式"><a href="#单例懒加载设计模式" class="headerlink" title="单例懒加载设计模式"></a>单例懒加载设计模式</h2><p>在设计模式中，通常会用到单例懒加载的设计模式，即在一个应用中只创建一个该类的对象，每次使用的都是同一对象，并且该对象在第一次获取时才创建，未被使用过的类对象不会被创建。</p>
<p>该设计模式通常使用double-checked locking方式，即看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Single sobj;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sobj == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(sobj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sobj == <span class="keyword">null</span>)&#123;</span><br><span class="line">          sobj = <span class="keyword">new</span> Single();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sobj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过两次判断sobj对象是否为空，才创建该类的对象，两次判断的原因为：</p>
<p>如果采用一次判断，那么每当调用getInstance方法时，都会使用synchronized上锁，我们只有在创建对象时需要上锁，而当创建好对象后每次获取对象时无需上锁，因此使用两次判断可以解决该问题。</p>
<p><strong>问题</strong></p>
<p>上述的代码看似没有问题，其实其中隐含着问题，我们需要从字节码指令的角度才能看出问题所在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0: getstatic #2		 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span></span><br><span class="line">6: ldc #3			 // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line">11: getstatic #2 	 // Field INSTANCE:Lcn/itcast/n5/Single;</span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line">17: new #3 			 // class cn/itcast/n5/Single</span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line">21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">24: putstatic #2 	 // Field INSTANCE:Lcn/itcast/n5/Single;</span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line">37: getstatic #2 	 // Field INSTANCE:Lcn/itcast/n5/Single;</span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure>

<p>其中第17-27行为创建对象的一系列指令：</p>
<ul>
<li>17行 new #3为创建一个实例，</li>
<li>20行 dup是拷贝引用，</li>
<li>21行 invokespecial #4为调用构造方法，</li>
<li>24行 putstatic为将对象的引用拷贝给static变量sobj。</li>
</ul>
<p>然而JVM可能会对这些代码进行重排序，即可能对象引用的拷贝给obj发生在对象调用构造方法之前，这样在多线程的环境下，由于执行了对象引用的拷贝但还没有执行构造函数就切换到其他线程，而在其他线程中，判断sobj不为空，那么就会返回还未调用构造函数的对象，而该对象被使用了。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gimw46l9hfj31760rqdio.jpg" alt="image-20200911183213619" style="zoom:50%;" />

<p>由于引用拷贝和调用构造函数会发生指令重排，因此当引用不为null时，对象可能还未在t1线程初始化完成，造成其他线程直接就开始使用该对象了，因此存在线程安全的隐患。</p>
<p>发生这一情况的主要原因是synchronized没有保护住全部的sobj对象，sobj在synchronized代码块外部还被使用到，如果一个变量全部位于synchronized代码块中，那么即使重排序也不会影响程序执行的结果。但现在的情况我们不能使用synchronized保护全部的sobj对象，这样会造成性能的损失。</p>
<p><strong>解决</strong></p>
<p>我们可以发现造成该问题的主要原因是指令重排序造成的，我们可以使用volatile禁用sobj的重排序。在给sobj变量加上volatile后，我们可以从字节码的角度看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span><br><span class="line">0: getstatic #2 		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span></span><br><span class="line">6: ldc #3 				// class cn/itcast/n5/Singleton</span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter -----------------------&gt; 保证原子性、可见性</span><br><span class="line">11: getstatic #2 		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line">17: new #3 				// class cn/itcast/n5/Singleton</span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line">21: invokespecial #4 	// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">24: putstatic #2 		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span></span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit ------------------------&gt; 保证原子性、可见性</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line">37: getstatic #2 		// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure>

<p>在加入volatile后， 24行的putstatic后加入了写屏障，那么invokespecial就不可能跑到24行之后，不会造成上面的问题了。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java并发-volatile</p><p><a href="http://example.com/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/">http://example.com/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>tomcode</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-09-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-09-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/"><span class="level-item">Netty核心组件-EventLoop与BootStrap</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://gitee.com/leizz1/pictures/raw/master/null/AF32230B-6341-40A5-BADE-7C898E5E858B(20190701-101.JPG" alt="tomcode"></figure><p class="title is-size-4 is-block line-height-inherit">tomcode</p><p class="is-size-6 is-block">努力努力再努力</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MrZhangL" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget is-sticky" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#Java内存模型-JMM"><span class="mr-2">1</span><span>Java内存模型(JMM)</span></a></li><li><a class="is-flex" href="#原子性"><span class="mr-2">2</span><span>原子性</span></a></li><li><a class="is-flex" href="#可见性"><span class="mr-2">3</span><span>可见性</span></a><ul class="menu-list"><li><a class="is-flex" href="#无法退出循环"><span class="mr-2">3.1</span><span>无法退出循环</span></a></li><li><a class="is-flex" href="#解决可见性的办法"><span class="mr-2">3.2</span><span>解决可见性的办法</span></a></li><li><a class="is-flex" href="#volatile对属性对象的可见性"><span class="mr-2">3.3</span><span>volatile对属性对象的可见性</span></a></li></ul></li><li><a class="is-flex" href="#有序性"><span class="mr-2">4</span><span>有序性</span></a><ul class="menu-list"><li><a class="is-flex" href="#流水线工作模式"><span class="mr-2">4.1</span><span>流水线工作模式</span></a></li><li><a class="is-flex" href="#JVM指令重排"><span class="mr-2">4.2</span><span>JVM指令重排</span></a></li><li><a class="is-flex" href="#volatile禁止指令重排"><span class="mr-2">4.3</span><span>volatile禁止指令重排</span></a></li><li><a class="is-flex" href="#单例懒加载设计模式"><span class="mr-2">4.4</span><span>单例懒加载设计模式</span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/JAVA/"><span class="level-start"><span class="level-item">JAVA</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="level-start"><span class="level-item">Java多线程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Netty/"><span class="level-start"><span class="level-item">Netty</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SSM/"><span class="level-start"><span class="level-item">SSM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-11T02:50:12.000Z">2020-09-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/">Java并发-volatile</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-10T09:07:11.000Z">2020-09-10</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/">Netty核心组件-EventLoop与BootStrap</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-09T08:43:51.000Z">2020-09-09</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/09/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoopGroup/">Netty核心组件-EventLoopGroup</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-08T07:57:22.000Z">2020-09-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/08/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ChannelFuture/">Netty核心组件-ChannelFuture</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-01T12:17:51.000Z">2020-09-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/01/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ByteBuf/">Netty核心组件-ByteBuf</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/netty/"><span class="tag">netty</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a><p class="size-small"><span>&copy; 2020 tomcode</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>