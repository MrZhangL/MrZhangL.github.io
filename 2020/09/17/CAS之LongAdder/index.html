<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>CAS之LongAdder - MrZhang</title><meta description="从JDK1.8开始，有提供了针对Long类型的原子累加器，为LongAdder与LongAccumulator，也针对Double类型的原子累加器，为DoubleAdder与DoubleAccumulator。jdk底层对DoubleAdder的实现是基于LongAdder的，因为两者都是占2个字节的变量。在此就以LongAdder为例。"><meta property="og:type" content="blog"><meta property="og:title" content="CAS之LongAdder"><meta property="og:url" content="http://example.com/2020/09/17/CAS%E4%B9%8BLongAdder/"><meta property="og:site_name" content="MrZhang"><meta property="og:description" content="从JDK1.8开始，有提供了针对Long类型的原子累加器，为LongAdder与LongAccumulator，也针对Double类型的原子累加器，为DoubleAdder与DoubleAccumulator。jdk底层对DoubleAdder的实现是基于LongAdder的，因为两者都是占2个字节的变量。在此就以LongAdder为例。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gis9n3omykj30yu0gst9q.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gitgeq6h75j32cu0ietb5.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gitfu1wy7xj31a40u0tdn.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gitgafgxmnj31ga0tmaek.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gisdq8kwr5j318u0o40uh.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gisedz3irqj31j00sm41p.jpg"><meta property="article:published_time" content="2020-09-17T02:48:28.000Z"><meta property="article:modified_time" content="2020-09-17T02:55:43.881Z"><meta property="article:author" content="tomcode"><meta property="article:tag" content="多线程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gis9n3omykj30yu0gst9q.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/09/17/CAS%E4%B9%8BLongAdder/"},"headline":"MrZhang","image":["https://tva1.sinaimg.cn/large/007S8ZIlly1gis9n3omykj30yu0gst9q.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gitgeq6h75j32cu0ietb5.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gitfu1wy7xj31a40u0tdn.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gitgafgxmnj31ga0tmaek.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gisdq8kwr5j318u0o40uh.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gisedz3irqj31j00sm41p.jpg"],"datePublished":"2020-09-17T02:48:28.000Z","dateModified":"2020-09-17T02:55:43.881Z","author":{"@type":"Person","name":"tomcode"},"description":"从JDK1.8开始，有提供了针对Long类型的原子累加器，为LongAdder与LongAccumulator，也针对Double类型的原子累加器，为DoubleAdder与DoubleAccumulator。jdk底层对DoubleAdder的实现是基于LongAdder的，因为两者都是占2个字节的变量。在此就以LongAdder为例。"}</script><link rel="canonical" href="http://example.com/2020/09/17/CAS%E4%B9%8BLongAdder/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/xcode.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-17T02:48:28.000Z" title="2020-09-17T02:48:28.000Z">2020-09-17</time>发表</span><span class="level-item"><time dateTime="2020-09-17T02:55:43.881Z" title="2020-09-17T02:55:43.881Z">2020-09-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></span><span class="level-item">24 分钟读完 (大约3586个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">CAS之LongAdder</h1><div class="content"><p>从JDK1.8开始，有提供了针对Long类型的原子累加器，为LongAdder与LongAccumulator，也针对Double类型的原子累加器，为DoubleAdder与DoubleAccumulator。jdk底层对DoubleAdder的实现是基于LongAdder的，因为两者都是占2个字节的变量。在此就以LongAdder为例。<a id="more"></a></p>
<h1 id="为什么要有LongAdder？"><a href="#为什么要有LongAdder？" class="headerlink" title="为什么要有LongAdder？"></a>为什么要有LongAdder？</h1><p>AtomicLong在高并发竞争激烈时，由于大量的线程需要不断进行CAS重试，占用CPU的计算资源，其并发性能收到较大的影响。LongAdder针对高并发场景做出了优化。</p>
<p><strong>性能测试比较：</strong></p>
<p>开启10个线程，每个线程对同一个long进行相加100000次，分别使用<code>AtomicLong</code>和<code>LongAdder</code>测试执行时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AtomicLong lg = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    LongAdder adder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    System.out.println(multiThreadTest(() -&gt; lg, (l) -&gt; l.incrementAndGet(), <span class="number">100</span>));</span><br><span class="line">    System.out.println(multiThreadTest(() -&gt; adder, (l) -&gt; l.add(<span class="number">1</span>), <span class="number">100</span>));</span><br><span class="line">    System.out.println(lg);</span><br><span class="line">    System.out.println(adder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Long <span class="title">multiThreadTest</span><span class="params">(Supplier&lt;T&gt; supplier, Consumer&lt;T&gt; consumer, <span class="keyword">int</span> nthreads)</span> </span>&#123;</span><br><span class="line">    T supply = supplier.get();</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;(nthreads);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</span><br><span class="line">        threads.add(<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">                consumer.accept(supply);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Long lastTime = System.currentTimeMillis();</span><br><span class="line">    threads.forEach((t)-&gt;t.start());</span><br><span class="line">    threads.forEach((t)-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis() - lastTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">207</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">10000000</span></span><br><span class="line"><span class="number">10000000</span></span><br></pre></td></tr></table></figure>

<p>我们可以看出两个测试最后都输出10000000，线程是安全的，但是100个线程对long累加100000次，在效率上AtomicLong比LongAdder慢几倍到10倍之多。</p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>LongAdder把一个变量拆分为多份，即把一个Long类型的变量拆分为一个Long类型的base与多个Cell，每个Cell内部也维护了一个Long类型的变量，当多个线程进行并发累加时，如果并发度底，就直接加到base上，如果并发度高，就会将加法操作分摊到Cell数组上，最后取值的时候只要base与这些Cell相加即可。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gis9n3omykj30yu0gst9q.jpg" alt="image-20200916100757842" style="zoom:50%;" />

<p>LongAdder的几个关键域：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table of cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;	<span class="comment">// 对应上图的各个Cell对象，一开始没有，懒加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base value, used mainly when there is no contention, but also as</span></span><br><span class="line"><span class="comment"> * a fallback during table initialization races. Updated via CAS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;		<span class="comment">// 对应上图的base</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spinlock (locked via CAS) used when resizing and/or creating Cells.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;		<span class="comment">// 在对cells数组进行扩容或创建时置为1，没有则为0，相当于锁</span></span><br></pre></td></tr></table></figure>



<p>从LongAdder的sum()方法可以看出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到对base变量以及各个Cell变量进行累加，当我们要获取LongAdder的值时，它便会进行累加返回结果。需要注意的是，在这里进行读取每个Cell进行累加时，并没有进行加锁的操作，这也意味着LongAdder不是强一致性，而是最终一致性。另外，base变量以及Cell中的long类型变量必须用volatile修饰，一是为了保证被修改了一定可见，二是保证long类型的写入和读取是原子的(volatile可以保证long、double类型读写操作的原子性)。</p>
<p>因此我们也可以看出<code>LongAdder</code>与<code>AtomicLong</code>的使用场景不同，<code>AtomicLong</code>适用与需要严格同步的场景，而<code>LongAdder</code>适合高并发修改但不需要严格同步的场景。</p>
<p>下面来看看LongAdder的核心方法<code>add(long x)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;	<span class="comment">// 首先对base进行CAS修改，成功就直接返回</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))		<span class="comment">// 取一个Cell数组中的cell进行修改，成功则返回</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>11行的if是进行对base变量的CAS修改，如果成功的话直接返回，因为已经修改成功。注意如果创建了Cell[]数组的话就不对base进行CAS了，直接到执行if里面的代码(cells为成员变量)</li>
<li>5~7行主要的逻辑为：<ul>
<li>无法取到Cell对象：Cell[]数组为空，或数组没有元素，或者选取到的数组对应索引的Cell对象没有创建就执行if中的代码，<code>getProbe()</code>为获取一个int数字，这个数字与线程的是相关的，同一个线程获取的数字每次都是相同的，Cell[]数组的长度为2的幂次方，因此与m进行与操作就是对m取余</li>
<li>能取到Cell对象：进行CAS修改操作，如果成功直接返回，失败就继续执行if代码块</li>
</ul>
</li>
</ul>
<p><code>longAccumulate()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        h = getProbe();	<span class="comment">// getProbe()是获取一个与当前线程有关的一个int变量，如果没有改变每次获取都是一样的</span></span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 死循环进行CAS操作直到成功</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;	<span class="comment">// Cell[]数组中有元素</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;		<span class="comment">// 取到数组上的索引对应的元素为空</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// cellsBusy表示是否正在创建新的Cell赋给Cell[]数组，0代表没有，1代表正在创建</span></span><br><span class="line">                    Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;		<span class="comment">// 创建Cell将要赋给Cell[]数组利用CAS将cellsBusy置为1</span></span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;	<span class="comment">// 将新new出来的Cell赋给Cell[]数组</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;	<span class="comment">// 解除标志位，可以看作锁</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;		<span class="comment">// 如果创建好了，r新添加进去就为x，累加成功，直接返回即可</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = advanceProbe(h);		<span class="comment">// 修改与线程相关的int使得下一次能够换一个累加单元进行累加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;	<span class="comment">// 检查是否正在被创建或者已经创建好了然后加锁</span></span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;					<span class="comment">// 加锁后进行检查cells是否已经创建好了</span></span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];	<span class="comment">// 创建一个Cell数组</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);	<span class="comment">// 创建一个Cell并赋值为此次的累加值x</span></span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;		<span class="comment">// 已经创建了一个累加单元值为x，相当于已经累加了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cells数组正在被创建，此线程不能再去创建，就对base进行一次CAS，成功便可直接返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))		</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在for循环中，第一层主要有3个if-else</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;...&#125;	<span class="comment">// cells数组已经被创建</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;...&#125;		<span class="comment">// cells数组还未被创建且未在被其他线程创建</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x)))) &#123;...&#125;	<span class="comment">// 其他线程正在创建cells数组</span></span><br></pre></td></tr></table></figure>

<p><strong>cells数组未被创建的情况(63~80行)：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gitgeq6h75j32cu0ietb5.jpg" alt="image-20200916153337981"></p>
<p>这里面主要是创建cells数组，用cellsBusy作为锁来防止多个线程同时创建</p>
<p><strong>cell数组已经被创建的情况(14~62行)：</strong></p>
<p>在这种情况下主要是已经有了cells数组，要在线程对应的累加单元上进行累加，我们一开始创建了cells数组，但是没有对cells数组中每个Cell进行初始化，所以当从数组中取到一个Cell想要累加时该Cell可能为空，因此我们需要初始化这个Cell(对应图中蓝色的框，具体逻辑见后面的图)。我们先来看对应位置处的Cell不为空的情况。</p>
<p>Cell不为空的情况：</p>
<ul>
<li>如果对应的Cell不为空，那首先会尝试对这个Cell进行CAS来累加（40~42行），如果成功了就可以直接返回了</li>
<li>如果CAS累加失败，就需要进行扩容（2倍扩容），扩容后直接进入下一次循环，能够扩容的条件为：<ul>
<li>数组的长度没有超过规定的上限NCPU（43行），NCPU与CPU数相关，一般等于CPU个数，因为我们知道CAS不断重试，最好不超过CPU数</li>
<li>数组没有正在被修改然后加锁成功（47行）</li>
</ul>
</li>
<li>如果不能扩容，就改变与线程绑定的int值（61行），就是h变量，h变量发生改变，下次进入循环获得的数组索引就会发生变化，换一个累加单元进行累加。上面扩容后再进入循环也能更换一个累加单元，所以直接进入循环不需要改变h。</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gitfu1wy7xj31a40u0tdn.jpg" alt="image-20200917102750543" style="zoom:45%;" />



<p>下面我们来看取到的Cell对象为空的情况，对应上图中蓝色的方框：</p>
<p>主要就是创建一个新的Cell对象放到索引位置，创建后放置需要对cells数组进行加锁</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gitgafgxmnj31ga0tmaek.jpg" alt="image-20200917104334995" style="zoom: 45%;" />

<h1 id="缓存行优化"><a href="#缓存行优化" class="headerlink" title="缓存行优化"></a>缓存行优化</h1><p>在Cell类的定义中，使用了一个<code>@sun.misc.Contended</code>的注解，该注解是JDK8之后引入的，用于CPU的缓存行优化。</p>
<p><strong>缓存行的介绍</strong></p>
<p>在介绍volatile时我们讲过CPU缓存架构，这里不再详细介绍。每个CPU都有L3级缓存，CPU的每个核都有L1，L2级缓存，主内存中的数据在进入CPU进行计算前会将数据拷贝到缓存中来进行缓存，但是CPU在拷贝数据进行缓存时，不会只单独拷贝那一份需要用到的数据，因为而是每次都会拷贝固定大小的内存数据进入缓存中，这个固定大小的缓存数据称为<code>缓存行</code>。</p>
<p>缓存行会包括需要的数据在内再加上相邻的数据组成固定大小的缓存行，这是由于我们再用到某个数据时，大概率后续还会用到其相邻的数据(例如数组)，因此设置一定的缓存行大小避免每次需要数据都必须去内存中又进行一次拷贝，但是缓存行的大小又不能太大，因为我们只是“大概率”会用到相邻的数据，本来缓存的大小就有限制，缓存行过大会导致拷贝太多暂时无用的数据进入缓存。在64位的x86系统中，<code>缓存行</code>的大小为<code>64个字节</code>，这是一个经验的取值。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gisdq8kwr5j318u0o40uh.jpg" alt="image-20200916122925311" style="zoom: 40%;" />

<p>如上图所示，主内存中有变量X，Y，Z连续排列（假设三个都是Long类型），那么当Core-1需要用到Y变量时，X，Y，Z极有可能存在于同一个缓存行中被加载到缓存当中，然后一起进入Core-1的缓存。而Core-2需要X变量，那么这个缓存行会被加载Core-2的缓存中。如果此时Core-1修改了数据Y，会导致整个缓存行(X,Y,Z)都失效，也就会往总线上发送消息，并将新的修改后的数据写回到主内存中，并通知Core-2对应的(X,Y,Z)缓存行失效，Core-2将重新从主内存中读取该缓存行。<strong>缓存行是各级缓存与内存数据交换的基本单位</strong>，无法只使得Y失效，<strong>要失效就整个缓存行失效</strong>，会导致X和Z也失效。</p>
<p><strong><code>@sun.misc.Contended</code>的作用</strong></p>
<p>有了上面缓存行的概念，我们可以看出LongAdder中存在的优化空间，由于在高并发环境下，LongAdder的累加通过Cell[]数组来进行实现，那么也就是说并发环境下，同时会有多个线程修改Cell[]数组不同的索引处的值，对于数组而言占用的是连续的存储空间，那么同一时刻它们在缓存中可能是这样的：</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gisedz3irqj31j00sm41p.jpg" alt="image-20200916125214383" style="zoom: 40%;" />

<p>如上图所示假设Cell[]数组的长度为8，加载到缓存中时，前三个元素在同一个缓存行1中，后5个元素在同一个缓存行2中，那么并发环境下Core-1正在修改了第一个元素，Core-2正在修改 第二个元素，Core-3正在修改第3个元素，Core-1修改成功后会导致缓存行1失效，那么Core-2和Core-3基于缓存一致性协议需要从内存中重新加载该缓存行数据，Core-2修改成功后Core-1和Core-3需要从内存中重新加载该缓存行，这样的效率是比较低的。</p>
<p><code>@sun.misc.Contended</code>主要是用Long去填充每个Cell，加入每个Cell都有8个Long类型的数据(只有一个Long是用于记录数据的)，那么每个相邻两个Cell不会位于同一个缓存行中（这并不代表每个Cell就是一个缓存行），这样Cell数据被修改不会影响其他其他Cell所在的缓存行，就不需要从内存中重新加载缓存行。</p>
<p>在著名的开源无锁并发框架Disruptor中，有类似的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBufferPad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;		<span class="comment">// 填充7个long型数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@sun.misc.Contended</code>在JDK8中被引入就是实现了上述的功能，使得某个类的大小占用8字节，使得该类的数组对象可以每个对象都不位于同一个缓存行中来避免并发修改数组时，缓存失效导致CPU需进行重新加载。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>CAS之LongAdder</p><p><a href="http://example.com/2020/09/17/CAS%E4%B9%8BLongAdder/">http://example.com/2020/09/17/CAS%E4%B9%8BLongAdder/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>tomcode</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-09-17</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-09-17</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/"><span class="level-item">Java并发-volatile</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://gitee.com/leizz1/pictures/raw/master/null/AF32230B-6341-40A5-BADE-7C898E5E858B(20190701-101.JPG" alt="tomcode"></figure><p class="title is-size-4 is-block line-height-inherit">tomcode</p><p class="is-size-6 is-block">努力努力再努力</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MrZhangL" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget is-sticky" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#为什么要有LongAdder？"><span class="mr-2">1</span><span>为什么要有LongAdder？</span></a></li><li><a class="is-flex" href="#基本原理"><span class="mr-2">2</span><span>基本原理</span></a></li><li><a class="is-flex" href="#缓存行优化"><span class="mr-2">3</span><span>缓存行优化</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/JAVA/"><span class="level-start"><span class="level-item">JAVA</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="level-start"><span class="level-item">Java多线程</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Netty/"><span class="level-start"><span class="level-item">Netty</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SSM/"><span class="level-start"><span class="level-item">SSM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-17T02:48:28.000Z">2020-09-17</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/17/CAS%E4%B9%8BLongAdder/">CAS之LongAdder</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-11T02:50:12.000Z">2020-09-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/">Java并发-volatile</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-10T09:07:11.000Z">2020-09-10</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/">Netty核心组件-EventLoop与BootStrap</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-09T08:43:51.000Z">2020-09-09</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/09/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoopGroup/">Netty核心组件-EventLoopGroup</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-08T07:57:22.000Z">2020-09-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/08/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ChannelFuture/">Netty核心组件-ChannelFuture</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/netty/"><span class="tag">netty</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a><p class="size-small"><span>&copy; 2020 tomcode</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>