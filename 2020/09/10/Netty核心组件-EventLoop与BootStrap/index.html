<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Netty核心组件-EventLoop与BootStrap - MrZhang</title><meta description="上一次我们讲到了EventLoopGroup，EventLoop的初始化跳过了，现在来深入研究EventLoop组件，EventLoop是Netty非常重要的组件，它是网络请求处理的核心，通过Selector不断循环监听Channel的事件，处理相应的请求。"><meta property="og:type" content="blog"><meta property="og:title" content="Netty核心组件-EventLoop与BootStrap"><meta property="og:url" content="http://example.com/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/"><meta property="og:site_name" content="MrZhang"><meta property="og:description" content="上一次我们讲到了EventLoopGroup，EventLoop的初始化跳过了，现在来深入研究EventLoop组件，EventLoop是Netty非常重要的组件，它是网络请求处理的核心，通过Selector不断循环监听Channel的事件，处理相应的请求。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gikf4o8uzuj312a0u0n1r.jpg"><meta property="og:image" content="https://gitee.com/leizz1/pictures/raw/master/null/image-20200910152925119.png"><meta property="og:image" content="https://gitee.com/leizz1/pictures/raw/master/null/image-20200910161126358.png"><meta property="article:published_time" content="2020-09-10T09:07:11.000Z"><meta property="article:modified_time" content="2020-09-10T09:07:18.677Z"><meta property="article:author" content="tomcode"><meta property="article:tag" content="netty"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gikf4o8uzuj312a0u0n1r.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/"},"headline":"MrZhang","image":["https://tva1.sinaimg.cn/large/007S8ZIlly1gikf4o8uzuj312a0u0n1r.jpg","https://gitee.com/leizz1/pictures/raw/master/null/image-20200910152925119.png","https://gitee.com/leizz1/pictures/raw/master/null/image-20200910161126358.png"],"datePublished":"2020-09-10T09:07:11.000Z","dateModified":"2020-09-10T09:07:18.677Z","author":{"@type":"Person","name":"tomcode"},"description":"上一次我们讲到了EventLoopGroup，EventLoop的初始化跳过了，现在来深入研究EventLoop组件，EventLoop是Netty非常重要的组件，它是网络请求处理的核心，通过Selector不断循环监听Channel的事件，处理相应的请求。"}</script><link rel="canonical" href="http://example.com/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/xcode.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-10T09:07:11.000Z" title="2020-09-10T09:07:11.000Z">2020-09-10</time>发表</span><span class="level-item"><time dateTime="2020-09-10T09:07:18.677Z" title="2020-09-10T09:07:18.677Z">2020-09-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Netty/">Netty</a></span><span class="level-item">29 分钟读完 (大约4335个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Netty核心组件-EventLoop与BootStrap</h1><div class="content"><p>上一次我们讲到了EventLoopGroup，EventLoop的初始化跳过了，现在来深入研究EventLoop组件，EventLoop是Netty非常重要的组件，它是网络请求处理的核心，通过Selector不断循环监听Channel的事件，处理相应的请求。<a id="more"></a></p>
<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gikf4o8uzuj312a0u0n1r.jpg" alt="image-20200909151322424" style="zoom: 67%;" />

<h2 id="EventLoop初始化"><a href="#EventLoop初始化" class="headerlink" title="EventLoop初始化"></a>EventLoop初始化</h2><p>之前我们讲到了<code>MultithreadEventExecutorGroup</code>类中<code>EventLoopGroup</code>的初始化，其中出现了下面两句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与线程数量相同的EventLoop</span></span><br><span class="line">children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"><span class="comment">// 创建EventLoop对象的数组，NioEventLoop</span></span><br><span class="line">children[i] = newChild(executor, args);</span><br></pre></td></tr></table></figure>

<p>这就是<code>EventLoopGroup</code>中初始化其中的<code>EventLoop</code>，其中newChild为一个抽象方法，该方法被子类<code>NioEventLoopGroup</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class NioEventLoopGroup</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EventLoopTaskQueueFactory queueFactory = args.length == <span class="number">4</span> ? (EventLoopTaskQueueFactory) args[<span class="number">3</span>] : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>], queueFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在结合<code>EventLoop</code>的构造函数看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,</span><br><span class="line">             EventLoopTaskQueueFactory queueFactory) &#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, newTaskQueue(queueFactory), newTaskQueue(queueFactory),</span><br><span class="line">            rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();	<span class="comment">// 使用SelectorProvider对象生成一个Selector对象</span></span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以明显的看出：</p>
<ul>
<li><code>NioEventLoop</code>中保存了自己属于哪个事件循环组，即<code>NioEventLoopGroup</code>.</li>
<li><code>NioEventLoop</code>中保存了一个线程池executor，这个线程池是<code>NioEventLoopGroup</code>在初始化时创建的线程池，也就是说这个线程池被其中的所有<code>NioEventLoop</code>共享.</li>
<li><code>NioEventLoop</code>中保存了一个<code>SelectorProvider</code>，用于产生<code>Selector</code>选择器对象，同样也保存了选择器对象selector</li>
<li><code>NioEventLoop</code>中保存了一个<code>SelectStrategy</code>，用于定义选择策略的，即判断是否有事件发生。我们主要用的<code>NioEventLoop</code>使用的是Nio提供的Selector的selectNow方法，Netty中还提供了<code>EpollEventLoop</code>使用的是自己实现的native方法来进行select，不同的select方式效率不同，不过Nio的select的效率也很高。</li>
</ul>
<h2 id="NioEventLoop父类的重要方法"><a href="#NioEventLoop父类的重要方法" class="headerlink" title="NioEventLoop父类的重要方法"></a>NioEventLoop父类的重要方法</h2><p>接下来我们来看看NioEventLoop的父类中有哪些比较重要的方法。</p>
<p><strong>(1) inEventLoop</strong></p>
<p>该方法是一个比较重要的方法，在父类<code>SingleThreadEventExecutor</code>中实现，该方法的主要功能是判断当前线程是否为对应EventLoop的线程。在Netty中，channel的读写操作都是在其对应的EventLoop的线程中完成的，channel每次进行读写操作，都先会检查是否在对应EventLoop线程中执行的，如果不是，将会提交给对应的EventLoop线程来执行，该方法就是用于判断当前线程是否在channel对应的EventLoop的线程中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thread == <span class="keyword">this</span>.thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>(2) addTask/removeTask/hasTask…</strong></p>
<p>该方法是给EventLoop中添加任务，在父类<code>SingleThreadEventExecutor</code>中实现。就像之前的Netty架构图中，EventLoop中具有一个任务队列TaskQueue，在EventLoop线程循环中，除了执行select然后处理读写事件之外，还会执行TaskQueue中的任务，这些方法就是给TaskQueue中添加任务等对任务队列进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务到队列</span></span><br><span class="line">    <span class="keyword">if</span> (!offerTask(task)) &#123;</span><br><span class="line">        <span class="comment">// 添加失败，则拒绝任务</span></span><br><span class="line">        reject(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>(3) register</strong></p>
<p><code>register(Channel channel)</code>方法是将Channel注册到该EventLoop上，也就是把Channel注册到对应的Selector上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="NioEventLoop的运行原理"><a href="#NioEventLoop的运行原理" class="headerlink" title="NioEventLoop的运行原理"></a>NioEventLoop的运行原理</h2><h3 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h3><p>NioEventLoop为事件循环，其中的run方法一旦运行起来就一直循环，来看看run方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;	<span class="comment">// 死循环，一直监听Selector上的channel是否有读写事件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:	<span class="comment">// 不会出现该情况</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                    <span class="comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    select(wakenUp.getAndSet(<span class="keyword">false</span>));	<span class="comment">// &lt;1&gt; 阻塞/循环判断是否有事件发生，有事件发生则返回</span></span><br><span class="line">                    <span class="comment">// 是否需要唤醒Selector</span></span><br><span class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// If we receive an IOException here its because the Selector is messed up. Let&#x27;s rebuild</span></span><br><span class="line">                <span class="comment">// the selector and retry. https://github.com/netty/netty/issues/8566</span></span><br><span class="line">                rebuildSelector0();		<span class="comment">// 重建一个Selector，将原来Selector上的Channel都注册到新的Selector上，关闭原来的Channel</span></span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();	<span class="comment">// &lt;2&gt; 处理所有的被选择的Key，即有事件发生的channel</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    runAllTasks();		<span class="comment">// &lt;3&gt; 执行所有任务队列中的任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 同时处理所有有事件发生的channel，然后执行任务队列中的任务，但是执行任务有时间限制，不能执行太久</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述的源码中我们可以看出，事件循环的流程：</p>
<ul>
<li>&lt;1&gt;通过select方法判断是否有事件发生，没有事件发生时，该方法会处于阻塞状态。在该方法中还处理了JDK的NIO存在空轮询的bug，后续再介绍。</li>
<li>&lt;2&gt;当已经监听到有事件发生，处理所有的SelectedKeys，完成对应channel的读写事件</li>
<li>&lt;3&gt;执行任务队列中的任务（可能是所有任务，也可能是部分）</li>
</ul>
<img src="https://gitee.com/leizz1/pictures/raw/master/null/image-20200910152925119.png" alt="image-20200910152925119" style="zoom:50%;" />

<h3 id="select-boolean-方法"><a href="#select-boolean-方法" class="headerlink" title="select(boolean)方法"></a>select(boolean)方法</h3><p>首先，JDK提供的NIO具有一个比较致命的bug，我们知道Selector监听事件发生有<code>int select()</code>、<code>int selectNow()</code>、<code>int select(long timeout)</code>三种方法：</p>
<ul>
<li><code>select()</code>：阻塞监听是否有事件发生，如果没有事件发生，该方法会一直阻塞</li>
<li><code>selectNow()</code>：判断是否有事件发生，该方法不会阻塞，会马上返回结果，没有事件发生就返回0</li>
<li><code>select(long timeout)</code>：带超时的阻塞监听是否有事件发生，如果没有事件发生，该方法首先会阻塞，超过指定事件后会自动唤醒，返回0。</li>
</ul>
<p>在Linux平台下，<code>select()</code>会出现没有事件发生但是还是会直接返回0，而不是进入阻塞状态，然后去processKeys但是没有key，任务队列也没有任务需要执行，这样的情况下会一直发生空轮询，导致CPU占用100%，对性能造成严重的损耗，Netty针对该bug进行了处理，就在<code>NioEventLoop</code>下的<code>select(boolean)</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;	<span class="comment">// 轮询计数器</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算轮询超时的时间</span></span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line">        <span class="keyword">long</span> normalizedDeadlineNanos = selectDeadLineNanos - initialNanoTime();</span><br><span class="line">        <span class="keyword">if</span> (nextWakeupTime != normalizedDeadlineNanos) &#123;</span><br><span class="line">            nextWakeupTime = normalizedDeadlineNanos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环判断是否有事件发生，尽管Selector的select()方法是阻塞的，但是在Linux下会有bug可能不阻塞，所以用循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="comment">// 如果空轮询超时，则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a task was submitted when wakenUp value was true, the task didn&#x27;t get a chance to call</span></span><br><span class="line">            <span class="comment">// Selector#wakeup. So we need to check task queue again before executing select operation.</span></span><br><span class="line">            <span class="comment">// If we don&#x27;t, the task might be pended until select operation was timed out.</span></span><br><span class="line">            <span class="comment">// It might be pended until idle timeout if IdleStateHandler existed in pipeline.</span></span><br><span class="line">            <span class="comment">// 如果任务队列中有任务需要执行了，那么就把Selector的唤醒标志置位true并退出循环去执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		   </span><br><span class="line">            <span class="comment">// 带超时的select(long timeout)方法监听是否有事件发生</span></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line">            <span class="comment">// 如果有事件发生了selectedKeys!=0，</span></span><br><span class="line">            <span class="comment">// 或者调用select(boolean)方法前唤醒标志为true，</span></span><br><span class="line">            <span class="comment">// 或者目前的唤醒标志位为true，</span></span><br><span class="line">            <span class="comment">// 或者任务队列有任务，</span></span><br><span class="line">            <span class="comment">// 或者有周期执行的任务。</span></span><br><span class="line">            <span class="comment">// 以上这些情况都退出此次监听</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="comment">// - Selected something,</span></span><br><span class="line">                <span class="comment">// - waken up by user, or</span></span><br><span class="line">                <span class="comment">// - the task queue has a pending task.</span></span><br><span class="line">                <span class="comment">// - a scheduled task is ready for processing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果线程被打断，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">// Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span></span><br><span class="line">                <span class="comment">// As this is most likely a bug in the handler of the user or it&#x27;s client library we will</span></span><br><span class="line">                <span class="comment">// also log it.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/2426</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Selector.select() returned prematurely because &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Thread.currentThread().interrupt() was called. Use &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 判断是否超时</span></span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                <span class="comment">// timeoutMillis elapsed without anything selected.</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                <span class="comment">// 在指定时间内(因为超时会退出循环重新计时)超过空轮询的次数，该Selector出现了bug，重建Selector</span></span><br><span class="line">                <span class="comment">// The code exists in an extra method to ensure the method is not too big to inline as this</span></span><br><span class="line">                <span class="comment">// branch is not very likely to get hit very frequently.</span></span><br><span class="line">                selector = selectRebuildSelector(selectCnt);</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.&quot;</span>,</span><br><span class="line">                        selectCnt - <span class="number">1</span>, selector);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(CancelledKeyException.class.getSimpleName() + <span class="string">&quot; raised by a Selector &#123;&#125; - JDK bug?&quot;</span>,</span><br><span class="line">                    selector, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Harmless exception - log anyway</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第 4 行：获得 select 操作的计数器。主要用于记录 Selector 空轮询次数，所以每次在正在轮询完成( 例如：轮询超时 )，则重置 <code>selectCnt</code> 为 1 。</p>
</li>
<li><p>第 8 行：计算 select 操作的截止时间，单位：纳秒。</p>
<ul>
<li><code>#delayNanos(currentTimeNanos)</code> 方法返回的为下一个定时任务距离现在的时间，如果不存在定时任务，则默认返回 1000 ms 。</li>
</ul>
</li>
<li><p>死循环调用<code>Selector</code>的<code>select(long timeout)</code>方法，直到满足下面的情况才退出循环：</p>
<ul>
<li>循环时间超时，18行</li>
<li>任务队列中有任务需要执行或者有周期任务执行，31行与46行</li>
<li>有channel发生了对应的读写事件，46行</li>
<li>被唤醒，wakeup为true，或调用<code>select(boolean)</code>之前传入的就是true，46行</li>
<li>线程被打断，一般不允许打断，打断了是出现bug或者错误使用，54行</li>
<li>在指定时间内发生了很多次空轮询，该<code>Selector</code>出现了bug，重建<code>Selector</code>后退出循环，74行~81行</li>
</ul>
</li>
</ul>
<h3 id="processSelectedKey方法"><a href="#processSelectedKey方法" class="headerlink" title="processSelectedKey方法"></a>processSelectedKey方法</h3><p><code>void processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code></p>
<p>该方法是处理每一个有事件发生的channel，在<code>run()</code>方法中调用processSelectedKeys方法会对所有发生事件的key调用到该方法来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        <span class="keyword">final</span> EventLoop eventLoop;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop = ch.eventLoop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">            <span class="comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span></span><br><span class="line">            <span class="comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span></span><br><span class="line">            <span class="comment">// to close ch.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个channel的EventLoop不是当前的EventLoop或该channel没有对应的EventLoop</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop != <span class="keyword">this</span> || eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭该通道，因为对应的k也不存在了</span></span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();	<span class="comment">// 获取该key发生了什么样的事件</span></span><br><span class="line">        <span class="comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span></span><br><span class="line">        <span class="comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 断开连接操作</span></span><br><span class="line">            <span class="comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/924</span></span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 写出操作</span></span><br><span class="line">            <span class="comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span></span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span></span><br><span class="line">        <span class="comment">// to a spin loop</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取操作</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，主要是走读取操作，即48行，对于服务端而言，无论是请求连接还是读取数据都是走这里。</p>
<h1 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h1><p>Netty中的BootStrap类主要是用于进行一些初始化设置，主要有<code>SeverBootStrap</code>和<code>BootStrap</code>两个类，分别用于服务端与客户端的初始化设置，以服务端的<code>ServerBootStrap</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建循环事件组，线程池，原理图中的BossGroup，用于监听用户的请求</span></span><br><span class="line">        <span class="comment">// 若不指定线程数量，会默认设置为当前机器的逻辑处理器✖2</span></span><br><span class="line">        EventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建工作线程组，原理图中的WorkerGroup</span></span><br><span class="line">        <span class="comment">// 若不指定线程数量，会默认设置为当前机器的逻辑处理器✖2</span></span><br><span class="line">        EventLoopGroup workExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 服务端配置</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            bootstrap.group(eventExecutors, workExecutors)      <span class="comment">// 将两个Group加入</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)     <span class="comment">// 指定channel的类型，注意这不是java NIO下的，是Netty提供的</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)      <span class="comment">// 设置线程队列的连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ServerHandler());       <span class="comment">// 每个注册进来的channel都添加一个处理器，可以添加多个</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);       <span class="comment">// 设置子处理器，当接受到读请求是会执行处理器中的方法。当是客户端请求连接时不会走该处理器，而是注册到workExecutors中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            ChannelFuture sync = bootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将来在接收到关闭事件是关闭通道，closeFuture本身是异步调用，加上sync同步等待返回结果</span></span><br><span class="line">            sync.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">            workExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到Netty服务端的启动都是由<code>ServerBootStrap</code>进行配置的，在执行<code>bootstrap.bind(8888).sync();</code>服务端正式启动起来。</p>
<h2 id="主要配置方法"><a href="#主要配置方法" class="headerlink" title="主要配置方法"></a>主要配置方法</h2><p><strong>(1) group()方法</strong></p>
<p>该方法用于指定事件循环组，传入了我们初始化好的bossGroup与workerGroup两个<code>NioEventLoopGroup</code>。</p>
<p><strong>(2) channel()方法</strong></p>
<p>用于指定服务端接收连接请求的channel类型，对应于NIO中的<code>ServerSocketChannel</code>，是Netty包装过的，一下为NIO对应的一些channel的类型。</p>
<img src="https://gitee.com/leizz1/pictures/raw/master/null/image-20200910161126358.png" alt="image-20200910161126358" style="zoom: 33%;" />

<p>其中我们常用的就是<code>NioServerSocketChannel</code>用于tcp协议(对应于NIO的<code>ServerSocketChannel</code>)，而<code>NioDatagramChannel</code>对应于UDP协议(对应于NIO的<code>DatagramChannel</code>)。</p>
<p><strong>(3) option()/childOption()方法</strong></p>
<p>用于配置TCP连接的参数，option()配置SeverSocketChannel的TCP参数，childOption()配置SocketChannel的TCP参数，具体的配置参数在<a target="_blank" rel="noopener" href="https://mrzhangl.github.io/2020/05/27/netty-zhong-de-channeloption-pei-zhi/">Netty中的ChannelOption配置</a>中有部分说明。</p>
<p><strong>(4) handler()/childHandler()方法</strong></p>
<p>用于配置channel的处理器，hanlder()用于配置<code>ServerSocketChannel</code>的Handler，childHandler()用于配置<code>socketChannel</code>的Handler。</p>
<h2 id="bind-启动服务器"><a href="#bind-启动服务器" class="headerlink" title="bind()启动服务器"></a>bind()启动服务器</h2><p>在经过配置后，调用bind()将启动服务器，开启两个<code>EventLoopGroup</code>中的<code>eventLoop</code>，调用bind()方法会调用到如下方法<code>AbstractBootstrap</code>的doBind方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class AbstractBootstrap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;1&gt;创建并初始化ServerSocketChannel</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        <span class="comment">// &lt;2&gt;绑定好了后，处理绑定完成的出站事件</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                    promise.registered();</span><br><span class="line"></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要执行了两个步骤：</p>
<ul>
<li>&lt;1&gt;创建并初始化ServerSocketChannel：包括对象的创建、先前配置参数的初始化、Handler链的初始化以及将channel注册到bossGroup等。</li>
<li>&lt;2&gt;绑定好了后，处理绑定完成的出站事件</li>
</ul>
<p>初始化主要与&lt;1&gt;相关，进入initAndRegister()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// &lt;1&gt;通过工厂创建一个ServerSocketChannel</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// &lt;2&gt;初始化channel</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span></span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;3&gt;将channel注册到boosGroup上</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span></span><br><span class="line">    <span class="comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span></span><br><span class="line">    <span class="comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span></span><br><span class="line">    <span class="comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span></span><br><span class="line">    <span class="comment">//    added to the event loop&#x27;s task queue for later execution.</span></span><br><span class="line">    <span class="comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span></span><br><span class="line">    <span class="comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span></span><br><span class="line">    <span class="comment">//         because register(), bind(), and connect() are all bound to the same thread.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;1&gt; 通过工厂创建一个<code>ServerSocketChannel</code>，channelFactory会根据之前配置的channel类型为<code>NioServerSocketChannel</code>生成该类的channel对象</p>
<p>&lt;2&gt; 初始化channel，设置配置参数，并将Handler加入channel的pipeline中，其中固定会加入一个用于处理连接请求的处理器，用于将接收到<code>SocketChannel</code>注册到workerGroup上的eventLoop上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    setChannelOptions(channel, options0().entrySet().toArray(newOptionArray(<span class="number">0</span>)), logger);</span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(newAttrArray(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="comment">// 配置参数</span></span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions =</span><br><span class="line">            childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="comment">// 添加用户自定义的Handler</span></span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加ServerBootstrapAcceptor的处理器，该处理器用于将接收到的连接请求封装为SocketChannel注册到workerGroup上</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt; 将channel注册到bossGroup，是通过<code>Channel</code>接口中的<code>unsafe</code>接口的方法的<code>void register(EventLoop eventLoop, ChannelPromise promise)</code></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Netty核心组件-EventLoop与BootStrap</p><p><a href="http://example.com/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/">http://example.com/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>tomcode</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-09-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-09-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/netty/">netty</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java并发-volatile</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/09/09/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoopGroup/"><span class="level-item">Netty核心组件-EventLoopGroup</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://gitee.com/leizz1/pictures/raw/master/null/AF32230B-6341-40A5-BADE-7C898E5E858B(20190701-101.JPG" alt="tomcode"></figure><p class="title is-size-4 is-block line-height-inherit">tomcode</p><p class="is-size-6 is-block">努力努力再努力</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MrZhangL" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget is-sticky" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#EventLoop"><span class="mr-2">1</span><span>EventLoop</span></a><ul class="menu-list"><li><a class="is-flex" href="#EventLoop初始化"><span class="mr-2">1.1</span><span>EventLoop初始化</span></a></li><li><a class="is-flex" href="#NioEventLoop父类的重要方法"><span class="mr-2">1.2</span><span>NioEventLoop父类的重要方法</span></a></li><li><a class="is-flex" href="#NioEventLoop的运行原理"><span class="mr-2">1.3</span><span>NioEventLoop的运行原理</span></a><ul class="menu-list"><li><a class="is-flex" href="#run-方法"><span class="mr-2">1.3.1</span><span>run()方法</span></a></li><li><a class="is-flex" href="#select-boolean-方法"><span class="mr-2">1.3.2</span><span>select(boolean)方法</span></a></li><li><a class="is-flex" href="#processSelectedKey方法"><span class="mr-2">1.3.3</span><span>processSelectedKey方法</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#BootStrap"><span class="mr-2">2</span><span>BootStrap</span></a><ul class="menu-list"><li><a class="is-flex" href="#主要配置方法"><span class="mr-2">2.1</span><span>主要配置方法</span></a></li><li><a class="is-flex" href="#bind-启动服务器"><span class="mr-2">2.2</span><span>bind()启动服务器</span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/JAVA/"><span class="level-start"><span class="level-item">JAVA</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="level-start"><span class="level-item">Java多线程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Netty/"><span class="level-start"><span class="level-item">Netty</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SSM/"><span class="level-start"><span class="level-item">SSM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-11T02:50:12.000Z">2020-09-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/">Java并发-volatile</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-10T09:07:11.000Z">2020-09-10</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/">Netty核心组件-EventLoop与BootStrap</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-09T08:43:51.000Z">2020-09-09</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/09/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoopGroup/">Netty核心组件-EventLoopGroup</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-08T07:57:22.000Z">2020-09-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/08/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ChannelFuture/">Netty核心组件-ChannelFuture</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-01T12:17:51.000Z">2020-09-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/01/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ByteBuf/">Netty核心组件-ByteBuf</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/netty/"><span class="tag">netty</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a><p class="size-small"><span>&copy; 2020 tomcode</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>