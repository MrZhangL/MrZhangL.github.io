<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Netty核心组件-ChannelFuture - MrZhang</title><meta description="Netty的特点就是异步非阻塞的网络框架，在Netty中，几乎所有的IO操作都是异步执行的，我们调用IO操作的方法后，方法会返回一个Future类型的对象(一般为ChannelFuture)，ChannelFuture继承于JDK的Future对象，对Future进行了扩充。"><meta property="og:type" content="blog"><meta property="og:title" content="Netty核心组件-ChannelFuture"><meta property="og:url" content="http://example.com/2020/09/08/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ChannelFuture/"><meta property="og:site_name" content="MrZhang"><meta property="og:description" content="Netty的特点就是异步非阻塞的网络框架，在Netty中，几乎所有的IO操作都是异步执行的，我们调用IO操作的方法后，方法会返回一个Future类型的对象(一般为ChannelFuture)，ChannelFuture继承于JDK的Future对象，对Future进行了扩充。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghr92niy85j30jt0czab2.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghrazdrjknj30go0f5wfb.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghrixt1yekj30zg0nc75u.jpg"><meta property="article:published_time" content="2020-09-08T07:57:22.000Z"><meta property="article:modified_time" content="2020-09-08T11:18:15.222Z"><meta property="article:author" content="tomcode"><meta property="article:tag" content="netty"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghr92niy85j30jt0czab2.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/09/08/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ChannelFuture/"},"headline":"MrZhang","image":["https://tva1.sinaimg.cn/large/007S8ZIlly1ghr92niy85j30jt0czab2.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1ghrazdrjknj30go0f5wfb.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1ghrixt1yekj30zg0nc75u.jpg"],"datePublished":"2020-09-08T07:57:22.000Z","dateModified":"2020-09-08T11:18:15.222Z","author":{"@type":"Person","name":"tomcode"},"description":"Netty的特点就是异步非阻塞的网络框架，在Netty中，几乎所有的IO操作都是异步执行的，我们调用IO操作的方法后，方法会返回一个Future类型的对象(一般为ChannelFuture)，ChannelFuture继承于JDK的Future对象，对Future进行了扩充。"}</script><link rel="canonical" href="http://example.com/2020/09/08/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ChannelFuture/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/xcode.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-08T07:57:22.000Z" title="2020-09-08T07:57:22.000Z">2020-09-08</time>发表</span><span class="level-item"><time dateTime="2020-09-08T11:18:15.222Z" title="2020-09-08T11:18:15.222Z">2020-09-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Netty/">Netty</a></span><span class="level-item">20 分钟读完 (大约3042个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Netty核心组件-ChannelFuture</h1><div class="content"><p>Netty的特点就是异步非阻塞的网络框架，在Netty中，几乎所有的IO操作都是异步执行的，我们调用IO操作的方法后，方法会返回一个Future类型的对象(一般为ChannelFuture)，ChannelFuture继承于JDK的Future对象，对Future进行了扩充。<a id="more"></a></p>
<h1 id="JDK中的Future"><a href="#JDK中的Future" class="headerlink" title="JDK中的Future"></a>JDK中的Future</h1><p>​    从JDK1.5开始官方提供了Callable和Future接口，通过这两个接口，可以使得父线程在子线程执行完后得到任务执行的结果。</p>
<p>​    当一个操作比较耗时，而后面将要执行的几个任务与这个操作的结果无关，此时我们可以考虑使用异步执行，这与前端js中的ajax是相同的原理。在执行该函数时，我们马上返回一个对象，将耗时的操作放在其他线程执行，这样我们在父线程中就可以进行其他的操作，真正的数据可以等到我们需要它的时候再从函数的返回对象中获取出来。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghr92niy85j30jt0czab2.jpg" alt="img"></p>
<h2 id="Callable与Runnable"><a href="#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h2><p>JDK的线程池中可以提交两种类型的接口，即Callable与Runnable。</p>
<p>​    java.lang.Runnable是JDK早期提供的线程相关的类，当创建一个线程时或者想线程池中提交一个任务时，需要将Runnable接口的对象传递进去，那么在线程分到时间片时就会自动的调用Runnable中唯一的run方法，该方法没有返回值。    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>​    而java.util.concurrent.Callable是JDK后续提供的，它也是一个接口，同样向线程池中提交一个任务时，也可传递以个Callable对象(自己创建线程时不能传递Callable对象，因为Thread没有提供Callable的构造函数)，Callable接口有一个方法call()，在线程分配到时间片时，会自动调用call()方法，与Runnbale不同的是，call()方法是有返回值的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>JDK中实现异步操作需要Callable配合Future使用，Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;		<span class="comment">// 取消任务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;														<span class="comment">// 判断任务是否取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;																	<span class="comment">// 任务是否完成</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;	<span class="comment">// 阻塞获取任务的结果</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>												<span class="comment">// 带超时的获取任务结果</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么如何通过Callable与Future来实现异步操作呢？在JDK提供的线程池ExecutorService中我们可以看到submit方法有不同的重载版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>这意味着我们想线程池中提交一个Callable方法可以得到一个Future对象，在未来的某个地方我们可以调用Future对象的get()方法来获取到该任务返回的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulePool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()*<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;submit other task&quot;</span>);</span><br><span class="line">        Future&lt;Integer&gt; hello = executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;main task start&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;main task end&quot;</span>);</span><br><span class="line">        Integer i = hello.get();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">57.249</span> com.zl.threadpool.SchedulePool [main] - submit other task</span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">57.284</span> com.zl.threadpool.SchedulePool [main] - main task start</span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">58.289</span> com.zl.threadpool.SchedulePool [main] - main task end</span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">58.789</span> com.zl.threadpool.SchedulePool [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - hello</span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">58.789</span> com.zl.threadpool.SchedulePool [main] - <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>​    从打印结果我们可以看到提交任务后我们马上拿到一个Future对象(此时任务还未执行完返回)，我们接着执行了打印操作，然后通过Future对象的get方法阻塞获取了先前提交任务的返回结果，直到任务完成后才拿到了结果打印。</p>
<p>​    本来两个任务需要1s+1.5s=2.5s才能够完成，现在只需要1.5s就能够完成。</p>
<p>​    提交Runnable对象就无法拿到返回的结果，不过也会返回一个Future对象，可以用于判断任务是否完成，即调用Future的get方法返回的是null，但是可以通过Future的isDone方法判断run方法是否执行完成。</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>​    不通过线程池提交任务，想要通过Thread类来实现异步调用后返回结果可以使用FutureTask类，FutureTask类其实也是实现了Runable接口，和Runable创建方法类似，此外，FutureTask还实现了Future接口，可通过FutureTask获取执行结果。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghrazdrjknj30go0f5wfb.jpg" alt="image-20200404180134501" style="zoom:67%;" />

<p>​    FutureTask的构造函数必须传入Callable对象，因此我们可以从FutureTask中get到Callable的执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread_FutureTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Integer integer = task.get();   <span class="comment">// 阻塞，等待task任务的返回结果</span></span><br><span class="line">        System.out.println(integer);    <span class="comment">// 打印1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Future的缺点"><a href="#Future的缺点" class="headerlink" title="Future的缺点"></a>Future的缺点</h2><p>只能用以下方式获取结果：</p>
<ol>
<li><code>V get()</code>阻塞等待</li>
<li>轮询<code>boolean isDone();</code></li>
<li>有限等待<code>V get(long timeout, TimeUnit unit)</code></li>
</ol>
<p>执行状态只有两种：</p>
<ol>
<li><code>boolean isDone();</code></li>
<li><code>boolean isCancelled();</code></li>
</ol>
<p>问题：</p>
<ul>
<li><p>接口中只有isDone()方法判断一个异步操作是否完成，但是对于完成的定义过于模糊，JDK文档指出正常终止、抛出异常、用户取消都会使isDone()方法返回真。在我们的使用中，我们极有可能是对这三种情况分别处理，而JDK这样的设计不能满足我们的需求。</p>
</li>
<li><p>对于一个异步操作，我们更关心的是这个异步操作触发或者结束后能否再执行一系列动作。比如说，我们浏览网页时点击一个按钮后实现用户登录。在javascript中，处理代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#login&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        login();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="Netty中的Future"><a href="#Netty中的Future" class="headerlink" title="Netty中的Future"></a>Netty中的Future</h1><p>​    鉴于JDK提供的Future对象的缺点，Netty对JDK的Future进行了扩展，同样也命名为Future，主要方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步操作完成且正常终止</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 异步操作是否可以取消</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancellable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 异步操作失败的原因</span></span><br><span class="line"><span class="function">Throwable <span class="title">cause</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 添加一个监听者，异步操作完成时回调，类比javascript的回调函数</span></span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line"><span class="comment">// 阻塞直到异步操作完成</span></span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 同上，但异步操作失败时抛出异常</span></span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 非阻塞地返回异步结果，如果尚未完成返回null</span></span><br><span class="line"><span class="function">V <span class="title">getNow</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>从Future对象中可以获取任务执行的状态：</p>
<p>未执行完成时，isDone返回false，其他的自然返回false。而当任务完成后，isDone为true，但是完成的状态可能是成功完成了，也可能是发生了异常，还可能是被取消对应于右边三个状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*                                      +---------------------------+</span><br><span class="line">*                                      | Completed successfully    |</span><br><span class="line">*                                      +---------------------------+</span><br><span class="line">*                                 +----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">* +--------------------------+    |    |   isSuccess() = <span class="keyword">true</span>      |</span><br><span class="line">* |        Uncompleted       |    |    +===========================+</span><br><span class="line">* +--------------------------+    |    | Completed with failure    |</span><br><span class="line">* |      isDone() = <span class="keyword">false</span>    |    |    +---------------------------+</span><br><span class="line">* |   isSuccess() = <span class="keyword">false</span>    |----+----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">* | isCancelled() = <span class="keyword">false</span>    |    |    |       cause() = non-<span class="keyword">null</span>  |</span><br><span class="line">* |       cause() = <span class="keyword">null</span>     |    |    +===========================+</span><br><span class="line">* +--------------------------+    |    | Completed by cancellation |</span><br><span class="line">*                                 |    +---------------------------+</span><br><span class="line">*                                 +----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">*                                      | isCancelled() = <span class="keyword">true</span>      |</span><br><span class="line">*                                      +---------------------------+</span><br></pre></td></tr></table></figure>



<p>在JDK中，我们从Future中获取的数据是从Callable接口的call方法返回值获取的，JDK的异步实现方式是Future+Callable。而在Netty中，并没有使用Callable接口，而是自己提供了Promise接口继承Future接口提供数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Promise</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 标记异步操作结果为成功，如果已被设置（不管成功还是失败）则抛出异常IllegalStateException</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span></span>;</span><br><span class="line">  	<span class="comment">// 同上，只是结果已被设置时返回False</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">(V result)</span></span>;</span><br><span class="line">		<span class="comment">// 设置失败</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">setFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">		<span class="comment">// 设置不可取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setUncancellable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，setSucess与setFailure只能被调用一次，任何一个方法被调用过了都不能再调用了，再次调用会抛出异常，两个方法会通知添加到其内部的Listener执行对应的行为。</p>
<p><strong>GenericFutureListener</strong></p>
<p>GenericFutureListener是Future对象的监听者，在Future对象完成任务后，回调其中的operationComplete方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericFutureListener</span>&lt;<span class="title">F</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked when the operation associated with the &#123;<span class="doctag">@link</span> Future&#125; has been completed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> future  the source &#123;<span class="doctag">@link</span> Future&#125; which called this callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(F future)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关于Netty异步调用的部分类结构图如下:</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghrixt1yekj30zg0nc75u.jpg" alt="image-20200815152347700" style="zoom:50%;" />

<p>​    </p>
<p><strong>AbstractFuture</strong></p>
<p>该抽象类实现了两个get()方法，阻塞等待获取异步执行的结果，下面给出其中一个，另外一个是带超时的get。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        await();	<span class="comment">// 阻塞等待唤醒</span></span><br><span class="line"></span><br><span class="line">        Throwable cause = cause();	<span class="comment">// 获取是否有异常</span></span><br><span class="line">        <span class="keyword">if</span> (cause == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getNow();	<span class="comment">// 无异常，直接返回结果，有可能还未执行完(被打断的情况)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> CancellationException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (CancellationException) cause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(cause);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>ChannelFuture</strong></p>
<p>ChannelFuture主要添加了两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回关联此Future对象的channel</span></span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 该Future是否有返回数据</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isVoid</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>DefaultPromise</strong></p>
<p>DefaultPromise实现了大多的Promise接口和Future接口的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (setSuccess0(result)) &#123;	<span class="comment">// 设置任务执行成功，并将结果放入</span></span><br><span class="line">        notifyListeners();			<span class="comment">// 通知监听者任务执行完成，做出相应动作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;complete already: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">setFailure</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (setFailure0(cause)) &#123;	<span class="comment">// 设置任务执行失败，并将原因放入</span></span><br><span class="line">        notifyListeners();		<span class="comment">// 通知监听者任务完成，做出相应的动作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;complete already: &quot;</span> + <span class="keyword">this</span>, cause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	Object result = <span class="keyword">this</span>.result;	<span class="comment">// 执行结果</span></span><br><span class="line">  	<span class="keyword">return</span> result != <span class="keyword">null</span> &amp;&amp; result != UNCANCELLABLE &amp;&amp; !(result <span class="keyword">instanceof</span> CauseHolder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>&#123;</span><br><span class="line">  	checkNotNull(listener, <span class="string">&quot;listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    	addListener0(listener);		<span class="comment">// 添加监听者</span></span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">if</span> (isDone()) &#123;</span><br><span class="line">    	notifyListeners();	<span class="comment">// 如果任务是完成了的，就通知所有的Listener</span></span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>让我们看一下通知监听者的细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = executor();	<span class="comment">// 获取executor()执行线程，在构造函数中传入</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;		<span class="comment">// 判断当前线程是否为executor</span></span><br><span class="line">        <span class="keyword">final</span> InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stackDepth = threadLocals.futureListenerStackDepth();</span><br><span class="line">        <span class="keyword">if</span> (stackDepth &lt; MAX_LISTENER_STACK_DEPTH) &#123;</span><br><span class="line">            threadLocals.setFutureListenerStackDepth(stackDepth + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                notifyListenersNow();	<span class="comment">// 通知执行operationComplete</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                threadLocals.setFutureListenerStackDepth(stackDepth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            notifyListenersNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，获取到该类中保存的executor，即执行任务的线程，该executor一定是eventLoop中的线程。跟着使用<code>executor.inEventLoop()</code>判断当前线程是否是excutor线程，是的的话直接执行通知监听者，不是的话则使用excutor线程执行通知监听者operationComplete方法。</p>
<h1 id="ChannelFuture的使用"><a href="#ChannelFuture的使用" class="headerlink" title="ChannelFuture的使用"></a>ChannelFuture的使用</h1><p>在服务端我们使用ChannelFuture：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.remove(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><