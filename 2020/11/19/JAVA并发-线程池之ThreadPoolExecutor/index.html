<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JAVA并发-线程池之ThreadPoolExecutor - MrZhang</title><meta description="ThreadPoolExecutor时JUC提供的一个有很多个普通线程的线程池，在实际生产中非常常用"><meta property="og:type" content="blog"><meta property="og:title" content="JAVA并发-线程池之ThreadPoolExecutor"><meta property="og:url" content="http://example.com/2020/11/19/JAVA%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor/"><meta property="og:site_name" content="MrZhang"><meta property="og:description" content="ThreadPoolExecutor时JUC提供的一个有很多个普通线程的线程池，在实际生产中非常常用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/leizz1/pictures/raw/master/img/image-20200514141610872.png"><meta property="og:image" content="https://gitee.com/leizz1/pictures/raw/master/img/image-20200514142622728.png"><meta property="article:published_time" content="2020-11-19T04:55:12.000Z"><meta property="article:modified_time" content="2020-11-19T11:30:49.652Z"><meta property="article:author" content="tomcode"><meta property="article:tag" content="多线程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/leizz1/pictures/raw/master/img/image-20200514141610872.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/11/19/JAVA%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor/"},"headline":"MrZhang","image":["https://gitee.com/leizz1/pictures/raw/master/img/image-20200514141610872.png","https://gitee.com/leizz1/pictures/raw/master/img/image-20200514142622728.png"],"datePublished":"2020-11-19T04:55:12.000Z","dateModified":"2020-11-19T11:30:49.652Z","author":{"@type":"Person","name":"tomcode"},"description":"ThreadPoolExecutor时JUC提供的一个有很多个普通线程的线程池，在实际生产中非常常用"}</script><link rel="canonical" href="http://example.com/2020/11/19/JAVA%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/xcode.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-11-19T04:55:12.000Z" title="2020-11-19T04:55:12.000Z">2020-11-19</time>发表</span><span class="level-item"><time dateTime="2020-11-19T11:30:49.652Z" title="2020-11-19T11:30:49.652Z">2020-11-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></span><span class="level-item">1 小时读完 (大约7231个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JAVA并发-线程池之ThreadPoolExecutor</h1><div class="content"><p>ThreadPoolExecutor时JUC提供的一个有很多个普通线程的线程池，在实际生产中非常常用<a id="more"></a></p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>JDK的并发工具包提供了线程池的框架如下：</p>
<img src="https://gitee.com/leizz1/pictures/raw/master/img/image-20200514141610872.png" alt="image-20200514141610872" style="zoom: 40%;" />

<p>最为常用的为ThreadPoolExecutor</p>
<p><strong>1）线程池的状态</strong></p>
<p>ThreadPoolExecutor中有一个int变量ctl用于存储线程池的状态以及线程池中线程的数量， 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>
<img src="https://gitee.com/leizz1/pictures/raw/master/img/image-20200514142622728.png" alt="image-20200514142622728" style="zoom: 40%;" />

<p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>





<p><strong>2）构造方法及线程池的工作方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,		// 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,	// 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,	// 救急线程在空闲后的存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,		// 时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,	// 任务等待队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,		    // 线程创建的工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;	<span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对构造函数需要参数进行说明：</p>
<ul>
<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务（懒惰创建）。</li>
<li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</li>
<li>如果队列<code>workQueue</code>选择了<strong>有界队列</strong>，那么<strong>任务数量超过了队列大小时</strong>，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。(注意，是等待队列满了才创建救急线程)</li>
<li>如果线程到达 <code>maximumPoolSize</code> 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 前4 种实现，其它著名框架也提供了实现<ul>
<li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li>
<li>CallerRunsPolicy 让调用者运行任务</li>
<li>DiscardPolicy 放弃本次任务</li>
<li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li>
<li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li>
<li>Netty 的实现，是创建一个新线程来执行任务</li>
<li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li>
<li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
</li>
<li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制。</li>
<li>线程池中线程的创建都是使用ThreadFactory的<code>Thread newThread(Runnable r);</code>方法来创建的，该接口只有这一个方法。</li>
</ul>
<h1 id="工厂方法创建线程池"><a href="#工厂方法创建线程池" class="headerlink" title="工厂方法创建线程池"></a>工厂方法创建线程池</h1><p>由于构造方法比较复杂，jdk提供了一些工厂方法来简便创建线程池，这些方法大多位于Executors类下：</p>
<p><strong>(1) newFixedThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务，因此就算核心线程数 != 最大线程数也不会有救急线程</li>
</ul>
<p>评价：适用于任务量已知，相对耗时的任务</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        AtomicInteger threadID = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 重写该方法主要用于指定创建线程时的一些行为，可以不重写采用默认的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;mypool_t&quot;</span> + threadID.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.execute(()-&gt; log.debug(<span class="string">&quot;&quot;</span> + i++));</span><br><span class="line">    service.execute(()-&gt; log.debug(<span class="string">&quot;&quot;</span> + i++));</span><br><span class="line">    service.execute(()-&gt; log.debug(<span class="string">&quot;&quot;</span> + i++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>(2) newCachedThreadPool</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点</p>
<ul>
<li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着全部都是救急线程(60s 后可以回收)，救急线程可以无限创建</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的(一手交钱、一手交货)</li>
</ul>
<p>评价:</p>
<p>​         整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况</p>
<p>补充SynchronousQueue：能够被取才能放入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue&lt;Integer&gt; integers = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;putting &#123;&#125; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">        integers.put(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125; putted...&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;putting...&#123;&#125; &quot;</span>, <span class="number">2</span>);</span><br><span class="line">        integers.put(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125; putted...&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;taking &#123;&#125;&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        integers.take();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;taking &#123;&#125;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        integers.take();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">36.861</span> com.zl.threadpool.JDKPool [t1] - putting <span class="number">1</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">37.861</span> com.zl.threadpool.JDKPool [t2] - taking <span class="number">1</span></span><br><span class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">37.861</span> com.zl.threadpool.JDKPool [t1] - <span class="number">1</span> putted...</span><br><span class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">37.861</span> com.zl.threadpool.JDKPool [t1] - putting...<span class="number">2</span> </span><br><span class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">38.863</span> com.zl.threadpool.JDKPool [t3] - taking <span class="number">2</span></span><br><span class="line"><span class="number">15</span>:<span class="number">19</span>:<span class="number">38.863</span> com.zl.threadpool.JDKPool [t1] - <span class="number">2</span> putted...</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在put(1)时，只有线程2在取的时候才能放入成功，否则就会进入阻塞。put(2)也是同理。</p>
<p>(3) newSingleThreadExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回的对象进行了包装，防止调用ThreadPoolExecutor实现类的特有方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService				</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>​        希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>
<p>区别：</p>
<ul>
<li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</li>
<li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改</li>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口<ul>
<li>因此不能调用 ThreadPoolExecutor 中特有的方法，防止程序员进行修改破坏单线程池的线程数量</li>
</ul>
</li>
<li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul>
<li>对外暴露的是 ThreadPoolExecutor 对象，程序员可以强转后调用 setCorePoolSize 等方法进行修改一些参数</li>
</ul>
</li>
</ul>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    service.execute(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.execute(()-&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    service.execute(()-&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;pool-1-thread-1&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.zl.threadpool.JDKPool.lambda$main$<span class="number">0</span>(JDKPool.java:<span class="number">20</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="number">15</span>:<span class="number">28</span>:<span class="number">53.655</span> com.zl.threadpool.JDKPool [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - <span class="number">2</span></span><br><span class="line"><span class="number">15</span>:<span class="number">28</span>:<span class="number">53.657</span> com.zl.threadpool.JDKPool [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，当这个单线程出现了错误会创建新的线程来执行接下来的任务。</p>
<h1 id="向线程池中提交任务"><a href="#向线程池中提交任务" class="headerlink" title="向线程池中提交任务"></a>向线程池中提交任务</h1><p>向线程池中提交任务的方法有很多，但是提交的任务只能是两种接口的实现类：</p>
<ul>
<li><code>Runnable</code>接口：接口中只有一个<code>public abstract void run();</code>方法，执行完任务后没有返回值</li>
<li><code>Callable&lt;V&gt;</code>接口：接口中只有一个<code>V call();</code>方法，执行完任务后有返回值</li>
</ul>
<p>下面来看一下提交任务的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execute</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// submit</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;	<span class="comment">// 提交Callable任务，返回值Future可异步获得任务执行结果，该方法不会阻塞</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);	<span class="comment">// 提交Runnable任务，返回值为Future&lt;Void&gt;，等价于没有返回值不会阻塞</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>; <span class="comment">// 提交Runnable任务，返回值为传入的result对象，可以在Runnable中修改result不会阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，该方法会阻塞，等待全部执行完成才继续</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)<span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br></pre></td></tr></table></figure>

<p>submit和invoke两种与excute差别在于传入Callable接口可以有返回值，对于InvokeXX方法，是会进行阻塞等待的，具体阻塞的动作在上面进行了描述，对于Future接口，在这里不做详细的描述。</p>
<p>不过submit也可以接收Runnable接口，但是返回值是Future&lt;Void&gt;，我们可以来查看一下submit方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractExecutorService</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);	<span class="comment">// 构造RunnableFuture对象</span></span><br><span class="line">    execute(ftask);		<span class="comment">// 执行execute</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，三种方式都是将其转化为了一个RunnableFuture接口的对象，newTask方法返回的是一个FutureTask类对象，在该对象中，存储了一个Callable的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    <span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// 返回的Future中的数据</span></span><br><span class="line">    <span class="comment">/** The thread running the callable; CASed during run() */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;		<span class="comment">// 执行该任务的线程</span></span><br><span class="line">    <span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当传入的是Runnable接口时，会利用适配器向Callable做一个适配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);	<span class="comment">// Runnable向Callable的适配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造好一个RunnableFuture对象后，便会调用线程池的<code>execute(Runnable command)</code>方法，通常来说，execute都是由子类实现的，不论线程池是什么样的逻辑，最终都是会调用的该Runnable的run方法，即FutureTask的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class FutureTask</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;	<span class="comment">// Callable返回的结果</span></span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();	<span class="comment">// 执行Callable中的call方法</span></span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;	<span class="comment">// 捕捉异常</span></span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);	<span class="comment">// 设置任务执行的结果，方便通过get方法获取</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>execute提交任务</strong></p>
<p>从上述的代码可以知道，调用submit方法最终也会调用到<code>execute(Runnable)</code>，现在跟踪<code>ThreadPoolExecutor</code>的该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();	<span class="comment">// 获取线程池当前的状态</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;	<span class="comment">// 如果当前工作线程的数量小于corePoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))  <span class="comment">// 添加一个worker(线程)</span></span><br><span class="line">            <span class="keyword">return</span>;	<span class="comment">// 添加成功则返回</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工作线程数量大于等于核心线程数量或添加新的线程执行任务失败将会继续执行下面的代码</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;	<span class="comment">// 向任务等待队列中添加一个新的任务</span></span><br><span class="line">        <span class="comment">// 线程池处于Running状态了或向任务队列中添加任务成功</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 检查线程池的状态，不处于Runing就执行拒绝策略，并从等待队列中移除该任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))	</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))	<span class="comment">// 否则再尝试一次添加新的worker</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execute代码逻辑：</p>
<ul>
<li>判断线程池中当前工作线程数量是否小于核心线程数量<code>corePoolSize</code></li>
<li><strong>如果工作线程数量小于核心线程数量</strong>，则代表线程池中的线程数量还每到规定的<code>corePoolSize</code>(线程池中的线程都是懒加载的)，那么优先创建一个新的线程来执行提交的任务：<ul>
<li><code>addWorker(command, true)</code>添加一个新的worker线程，并将提交的Runnable对象传给该worker，虽然在这里判断是可以添加线程的，但是由于线程池会被并发调用，可能进入addWorker时线程数量已经满了，因此addWorker会有一个返回值true或false代表添加线程成功还是失败。输入的参数true或false代表是否能添加线程的条件是用<code>corePoolSize</code>作为界限还是<code>maximumPoolSize</code>作为界限。</li>
<li>如果添加成功了，则可以直接返回，如果失败了还需要执行后续的逻辑</li>
</ul>
</li>
<li><strong>如果工作线程数量大于核心线程数量或在上一步中添加线程失败</strong>，则便会向等待队列<code>workerQueue</code>中添加该任务：<ul>
<li>添加完过后会马上检查线程池是否处于运行状态，如果未处于运行状态就回滚(即从等待队列中移除刚刚提交的任务)，并且执行拒绝策略</li>
<li>如果线程池还处于运行状态，那么会判断线程池中的线程数量是否为0，如果为0了那么刚刚放入等待队列中的任务就无法执行，那么就向线程池中添加一个线程。</li>
</ul>
</li>
<li><strong>如果任务放入等待队列中失败了</strong>，那么会再尝试添加一次新的worker，还是不行就执行拒绝策略</li>
</ul>
<p>在execute的源码中，反复地用到了<code>addWorker</code>方法，再来跟踪一下该方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 当线程池不处于Running状态应该返回false，但是有一种情况除外，那就是任务队列中有任务而这次调用</span></span><br><span class="line">        <span class="comment">// addWorker只是为了添加一个工作线程避免任务队列中的任务无法执行</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))	<span class="comment">// 线程的数量是否超过界限</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))	<span class="comment">// CAS增加线程的数量</span></span><br><span class="line">                <span class="keyword">break</span> retry;	<span class="comment">// 成功就直接break</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;	<span class="comment">// CAS失败就继续重试</span></span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 要向线程池中添加线程了，上锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">			   <span class="comment">// 线程池处于运行状态或者是需要一个线程执行任务队列中的任务则可以添加线程</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);		<span class="comment">// 向存储了所有线程的Set中添加一个worker</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 如果添加成功了就启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)	<span class="comment">// 如果线程没有正常启动，则添加失败，进行线程数量的回滚等操作</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;	<span class="comment">// 线程是否成功启动即为是否添加成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addWorker的代码逻辑：</p>
<ul>
<li>3~28行：采用CAS来对线程池中的线程数量进行+1，如果在该过程中发现线程的数量已经大于了规定的界限，就返回false不能添加worker线程了，否则循环这个过程直到CAS成功。<ul>
<li>线程数量的界限有两种：<code>corePoolSize</code>与<code>maximumPoolSize</code>，用哪一个取决于调用该方法时传入的boolean参数</li>
</ul>
</li>
<li>33~69行：向线程池中添加一个工作线程，线程池中的所有线程都保存在一个<code>Set&lt;Worker&gt;</code>的集合中，即添加线程到该集合中：<ul>
<li>创建一个新的worker线程，new一个Worker对象就是创建了一个新的线程</li>
<li>进行上锁，因为要向线程池的集合中添加worker了</li>
<li>线程池处于运行状态或者是需要一个线程执行任务队列中的任务则可以添加该线程，将线程添加到Set中</li>
<li>添加成功就调用start方法启动该worker线程</li>
<li>启动成功就可以返回了，启动失败则需要回滚线程池的线程数量，并从Set中移除该worker</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>从<code>execute</code>方法和<code>addWorker</code>方法可以看出提交一个任务的总体逻辑：</p>
<ul>
<li>如果线程池中的线程数量小于<code>corePoolSize</code>，那么会直接创建一个新的线程来执行该任务，不管线程池中是否有空闲的线程</li>
<li>当线程池中的线程数量大于等于<code>corePoolSize</code>时，需要添加任务则会将任务放到任务队列中，线程池中的所有线程都是从任务队列中取任务来执行</li>
<li>如果一个任务没法创建一个新的线程执行，添加到阻塞队列中也失败，则会执行拒绝策略。</li>
</ul>
<h1 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h1><p>在线程池中，任务的执行都是由各个worker线程完成，worker线程类的定义如下，它是ThreadPoolExecutor的内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...一些AQS的实现方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在Worker中保存了一个线程Thread，一个Runnable的任务(从之前分析我们可以知道是一个FutureTask对象)，还有一个长整型的变量来记录该线程完成过的任务数量。</p>
<p>可以看到Worker类中的构造方法，在构造时，会创建一个新的线程，并且将Worker本身传递thread类中，那么当调用该thread的start方法后，就会执行Worker的run方法，而worker的run方法调用的是ThreadPoolExecutor的runWorker方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class ThreadPoolExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;	<span class="comment">// 取出Worker绑定的任务</span></span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;		<span class="comment">// 将Worker的绑定任务置为空</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 一直循环，getTask()从等待队列中拿取任务，会阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;	</span><br><span class="line">            w.lock();	<span class="comment">// 给该worker上锁，其他的线程不能执行该worker</span></span><br><span class="line">            <span class="comment">// 处理线程池被关闭的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);	<span class="comment">// 任务执行前回调，空方法，子类可以做定制化</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();		<span class="comment">// 执行任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);	<span class="comment">// 任务执行后回调，空方法，子类可以做定制化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();		<span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出了循环，说明该线程需要被销毁了</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;	<span class="comment">// 如果任务执行有异常，该赋值语句就不会执行</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 任务执行完了，后置处理，如果有异常，completedAbruptly为true</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runWorker代码的逻辑：</p>
<ul>
<li>取出Worker中存储的Runnable任务，Worker中存储了Runnable任务是在Worker初始化时赋予的任务，当这个任务执行完以后，Worker中存的任务就都为空了，需要从等待队列中取。</li>
<li>while循环通过<code>getTask()</code>方法一直从workerQueue等待队列中取任务：<ul>
<li>如果这个线程是核心线程，那么就调用BlockingQueue的<code>take()</code>方法阻塞获取任务。</li>
<li>如果这个线程是救急线程，那么就会调用BlockingQueue的<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>方法，在存活时间keepAliveTime内如果没有获取任务就返回null，一旦返回null了while循环将退出，该线程任务执行完毕被关闭</li>
<li>如果线程池被关闭了，getTask()也会返回null，线程退出</li>
</ul>
</li>
<li>获取到任务后，先上锁，再执行任务。执行任务的过程中，线程池通过两个方法<code>beforeExecute</code>和<code>afterExecute</code>在任务执行前后分别进行回调。</li>
<li>如果任务执行的过程中，遇到了异常将会抛出，被最外层的try块捕获到，那么39行的<code>completedAbruptly = false;</code>将不会执行，那么最后会执行<code>processWorkerExit</code>会将<code>completedAbruptly</code>传入告知是否有异常。</li>
</ul>
<p>我们可以再来跟踪一下捕获到一样后，会对该线程做出什么样的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class ThreadPoolExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是遇到了异常，则该线程退出，线程池中的线程数量减1</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 记录线程池总的执行任务的数量</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);	<span class="comment">// 将本线程的Worker从Set中移除</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试终止线程池，即所有任务都执行完毕，该线程退出后所有线程也关闭就可以终止，否则不终止</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;	<span class="comment">// 线程池处于Running或Shutdown状态可以进入</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;<span class="comment">// 如果不是有异常，那么则代表可能是救急线程要退出或线程池处于SHUTDOWN状态</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;  <span class="comment">// 当前状态下需要的最小线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())	<span class="comment">// 如果允许的最小线程数量为0但是任务队列中还有任务</span></span><br><span class="line">                min = <span class="number">1</span>;	<span class="comment">// 则将最小线程数置为1，以保证任务可以被执行</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)	</span><br><span class="line">                <span class="comment">// 如果当前线程池中的线程数量大于等于需要的最小线程数量，则代表不用添加线程了，直接返回</span></span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是遇到了异常，就直接添加一个worker</span></span><br><span class="line">        <span class="comment">// 或线程池中的线程数量小于了需要的最小数量，那么本线程退出，应该加一个新的线程到线程池中</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processWorkerExit主要是完成线程退出的一系列活动，其代码的逻辑为：</p>
<ul>
<li>如果是遇到了异常导致的线程退出，那么就将线程数减1，正常退出不需要减1，因为正常退出的时候，在<code>getTask()</code>中就会减1了</li>
<li>将线程从Set中移除</li>
<li>线程池处于Running或Shutdown状态则执行后续的逻辑，否则直接返回即可</li>
<li>如果不是有异常发生而退出线程，则可能是救急线程退出，也有可能是线程池被关闭了，此时通过<code>allowCoreThreadTimeOut</code>变量来判断是否是被关闭：<ul>
<li>如果没有被关闭，那么当前状态需要的最小线程数量为<code>corePoolSize</code>，即核心线程数量</li>
<li>如果是SHUTDOWN了，那么需要的最小线程数量为0，但是如果等待队列中还有任务，需要把任务执行完，那么需要的最小线程数量为1</li>
<li>如果线程池中的线程数量大于等于最小需要的线程数量，该线程就直接退出了，如果线程数量少了，则会执行后续的添加一个Worker</li>
</ul>
</li>
<li>如果是发生了异常而导致线程退出，或者当前的线程数量少于了所需要的最小线程数量(即线程数量不够)，那么就向线程中添加一个新的Worker线程，本线程最后还是退出。</li>
</ul>
<h1 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h1><p>线程池的关闭主要有<code>shutdown</code>和<code>shutdownNow</code>方法：</p>
<ul>
<li><code>void shutdown()</code>：关闭线程池，线程池变为SHUTDOWN状态，开始不接收新的任务，但是<strong>正在执行与在任务队列中的任务</strong>会继续执行完，线程池才算完全关闭，该方法不会阻塞。</li>
<li><code>List&lt;Runnable&gt; shutdownNow()</code>：关闭线程池，开始不接收新的任务，同时正在执行的任务也会去进行打断(打断不代表不能继续执行了)，并且将任务队列中的所有任务作为一个List返回。</li>
</ul>
<p>下面来跟踪<code>void shutdown</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();	<span class="comment">// 修改线程池中的线程先上锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();	<span class="comment">// 检查当前线程是否有关闭线程池的权限</span></span><br><span class="line">        advanceRunState(SHUTDOWN);	<span class="comment">// 主要是CAS自旋将线程池的状态修改为SHUTDOWN</span></span><br><span class="line">        interruptIdleWorkers();		<span class="comment">// 打断所有的空闲线程，即对每个没有在执行任务的线程调用Interrupt方法</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();		<span class="comment">// 尝试去终止线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面部分的代码逻辑都比较简单，就是修改线程池状态与打断线程：</p>
<ul>
<li>由前面的第三节的分析可知，当线程池处于SHUTDOWN状态时，<code>getTask()</code>方法将会返回null，进而退出线程，<code>shutdown</code>方法会将线程池的状态设置为SHUTDOWN</li>
<li>而打断所有没有在执行任务的线程就是让<code>getTask()</code>在阻塞时也能继续执行，否则<code>getTask()</code>就无法继续执行返回null了。</li>
</ul>
<p>下面主要来看一看<code>tryTerminate</code>方法，这个方法我们不是第一次见到了，从字面意思就能看出是尝试去终止线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();	<span class="comment">// 获取线程池当前的状态</span></span><br><span class="line">        <span class="comment">// 如果线程池在RUNNING状态，表示不能关闭</span></span><br><span class="line">        <span class="comment">// 如果线程池已经被设置为TIDYING或TERMINATED就代表已经在terminate了，不需要再重复去关闭</span></span><br><span class="line">        <span class="comment">// 如果线程池处于SHUTDOWN状态但是等待队列不为空，不能进行terminate</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||		</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果能本来能进行terminate了，但是工作线程的数量不为0，那么要再去打断那些线程</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();	<span class="comment">// 上锁，要对线程池整体操作了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;	<span class="comment">// 将线程池状态变为TIDYING</span></span><br><span class="line">                <span class="comment">// 成功变为TIDYING后进行teminate</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 进行terminate，这是个空方法，子类可以定制终止时进行某些操作</span></span><br><span class="line">                    terminated();	</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));	<span class="comment">// terminate完成，将状态变为TERMINATED</span></span><br><span class="line">                    termination.signalAll();	<span class="comment">// 唤醒等待终止的线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是属于比较软的一种方法，它是尝试去关闭线程池，如果它判断当前线程池的状态不是可以去执行terminate的时候，将会直接返回，线程池可以关闭去执行terminate方法的条件为：</p>
<ul>
<li>线程池状态处于SHUTDOWN或STOP</li>
<li>线程池中的线程都退出了，并且任务队列为空</li>
</ul>
<p><code>tryTerminate</code>被调用的地方放有很多，在shutdown执行时，如果有任务正在执行，shutdown中的<code>tryTerminate</code>会失败而返回，但是在之前的第三节中，我们看到了每个线程在退出时会执行<code>tryTerminate</code>，这样最后一个线程在退出时会关闭线程池。</p>
<p>因此tryTerminate方法的逻辑为：</p>
<ul>
<li>判断线程池是否可以进行关闭：<ul>
<li>如果线程池在RUNNING状态，线程池正在允许，没有shutdown，当然不能关闭，到这里状态还是可能为RUNNING，因为tryterminate在很多地方都调用了</li>
<li>如果线程池已经被设置为TIDYING或TERMINATED就代表已经在terminate了，不需要再重复去关闭</li>
<li>如果线程池处于SHUTDOWN状态但是等待队列不为空，不能进行terminate</li>
<li>工作线程的数量不为0，不能关闭线程池，还要要再去打断那些线程</li>
</ul>
</li>
<li>执行线程池关闭：<ul>
<li>上锁，防止重复terminate</li>
<li>CAS将线程池状态修改为TIDYING，如果失败了代表此次tryTerminate失败</li>
<li>执行terminate方法，在TreadPoolExecutor中该方法为空方法</li>
<li>执行完terminate方法后将线程状态设置为TERMINATED</li>
<li>唤醒所有等待线程池终止的线程</li>
</ul>
</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>JAVA并发-线程池之ThreadPoolExecutor</p><p><a href="http://example.com/2020/11/19/JAVA%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor/">http://example.com/2020/11/19/JAVA%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>tomcode</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-11-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-11-19</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/11/06/Nacos%E6%BA%90%E7%A0%81(3)-Distro%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"><span class="level-item">Nacos源码(3)-Distro数据同步</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://gitee.com/leizz1/pictures/raw/master/null/AF32230B-6341-40A5-BADE-7C898E5E858B(20190701-101.JPG" alt="tomcode"></figure><p class="title is-size-4 is-block line-height-inherit">tomcode</p><p class="is-size-6 is-block">努力努力再努力</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MrZhangL" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget is-sticky" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#构造函数"><span class="mr-2">1</span><span>构造函数</span></a></li><li><a class="is-flex" href="#工厂方法创建线程池"><span class="mr-2">2</span><span>工厂方法创建线程池</span></a></li><li><a class="is-flex" href="#向线程池中提交任务"><span class="mr-2">3</span><span>向线程池中提交任务</span></a></li><li><a class="is-flex" href="#任务执行"><span class="mr-2">4</span><span>任务执行</span></a></li><li><a class="is-flex" href="#线程池的关闭"><span class="mr-2">5</span><span>线程池的关闭</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/JAVA/"><span class="level-start"><span class="level-item">JAVA</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="level-start"><span class="level-item">Java多线程</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Netty/"><span class="level-start"><span class="level-item">Netty</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SSM/"><span class="level-start"><span class="level-item">SSM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-19T04:55:12.000Z">2020-11-19</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/19/JAVA%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor/">JAVA并发-线程池之ThreadPoolExecutor</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-06T11:24:35.000Z">2020-11-06</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/06/Nacos%E6%BA%90%E7%A0%81(3)-Distro%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/">Nacos源码(3)-Distro数据同步</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-05T07:24:35.000Z">2020-11-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/05/JAVA%E5%B9%B6%E5%8F%91-AQS/">JAVA并发-AQS</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-30T13:51:55.000Z">2020-10-30</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/30/Nacos%E6%BA%90%E7%A0%81(2)-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B/">Nacos源码(2)-服务注册流程</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-29T10:16:35.000Z">2020-10-29</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/29/Nacos%E6%BA%90%E7%A0%81(1)-Nacos%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%BA%90%E7%A0%81%E5%90%AF%E5%8A%A8/">Nacos源码(1)-Nacos服务端源码启动</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nacos/"><span class="tag">nacos</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/netty/"><span class="tag">netty</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a><p class="size-small"><span>&copy; 2020 tomcode</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>