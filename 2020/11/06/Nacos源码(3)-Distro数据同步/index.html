<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Nacos源码(3)-Distro数据同步 - MrZhang</title><meta description="上一节说到服务的注册，是在单机模式下的，Nacos更常用的是集群模式，在集群模式下，必定会遇到数据一致性的问题，Nacos对保证数据一致性的策略有两种：AP模式(最终一致性)与CP模式(强一致性)。在Nacos中，AP模式采用的是一种叫Distro的协议，这是阿里巴巴内部定义的一套协议，来有效解决集群数据同步的问题。"><meta property="og:type" content="blog"><meta property="og:title" content="Nacos源码(3)-Distro数据同步"><meta property="og:url" content="http://example.com/2020/11/06/Nacos%E6%BA%90%E7%A0%81(3)-Distro%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"><meta property="og:site_name" content="MrZhang"><meta property="og:description" content="上一节说到服务的注册，是在单机模式下的，Nacos更常用的是集群模式，在集群模式下，必定会遇到数据一致性的问题，Nacos对保证数据一致性的策略有两种：AP模式(最终一致性)与CP模式(强一致性)。在Nacos中，AP模式采用的是一种叫Distro的协议，这是阿里巴巴内部定义的一套协议，来有效解决集群数据同步的问题。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkfgg8cayjj30vo0fq754.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkfh57963jj31jj0u0gou.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkfi2pmllvj31se0u0ad0.jpg"><meta property="article:published_time" content="2020-11-06T11:24:35.000Z"><meta property="article:modified_time" content="2020-11-08T02:31:47.000Z"><meta property="article:author" content="tomcode"><meta property="article:tag" content="nacos"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1gkfgg8cayjj30vo0fq754.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/11/06/Nacos%E6%BA%90%E7%A0%81(3)-Distro%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"},"headline":"MrZhang","image":["https://tva1.sinaimg.cn/large/0081Kckwly1gkfgg8cayjj30vo0fq754.jpg","https://tva1.sinaimg.cn/large/0081Kckwly1gkfh57963jj31jj0u0gou.jpg","https://tva1.sinaimg.cn/large/0081Kckwly1gkfi2pmllvj31se0u0ad0.jpg"],"datePublished":"2020-11-06T11:24:35.000Z","dateModified":"2020-11-08T02:31:47.000Z","author":{"@type":"Person","name":"tomcode"},"description":"上一节说到服务的注册，是在单机模式下的，Nacos更常用的是集群模式，在集群模式下，必定会遇到数据一致性的问题，Nacos对保证数据一致性的策略有两种：AP模式(最终一致性)与CP模式(强一致性)。在Nacos中，AP模式采用的是一种叫Distro的协议，这是阿里巴巴内部定义的一套协议，来有效解决集群数据同步的问题。"}</script><link rel="canonical" href="http://example.com/2020/11/06/Nacos%E6%BA%90%E7%A0%81(3)-Distro%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/xcode.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-11-06T11:24:35.000Z" title="2020-11-06T11:24:35.000Z">2020-11-06</time>发表</span><span class="level-item"><time dateTime="2020-11-08T02:31:47.000Z" title="2020-11-08T02:31:47.000Z">2020-11-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><span class="level-item">26 分钟读完 (大约3967个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Nacos源码(3)-Distro数据同步</h1><div class="content"><p>上一节说到服务的注册，是在单机模式下的，Nacos更常用的是集群模式，在集群模式下，必定会遇到数据一致性的问题，Nacos对保证数据一致性的策略有两种：AP模式(最终一致性)与CP模式(强一致性)。在Nacos中，AP模式采用的是一种叫Distro的协议，这是阿里巴巴内部定义的一套协议，来有效解决集群数据同步的问题。<a id="more"></a></p>
<h1 id="Nacos通信架构"><a href="#Nacos通信架构" class="headerlink" title="Nacos通信架构"></a>Nacos通信架构</h1><h2 id="客户端与服务通信"><a href="#客户端与服务通信" class="headerlink" title="客户端与服务通信"></a>客户端与服务通信</h2><p><strong><font size=4px>(1) 单机模式</font></strong></p>
<p>在单机模式下，Nacos客户端与单台Nacos服务端进行交互，包括以下几类：</p>
<ul>
<li><code>CRUD</code>：对Nacos注册中心服务信息的CRUD操作</li>
<li><code>HeartBeat</code>：心跳，如果Nacos客户端将某个服务注册到了服务端，那么客户端需要不停地向服务端发送有关服务的心跳。默认情况下，如果服务端15s内容没有收到该服务的心跳包，那么会将其标记为不健康的实例，如果超过30s没有收到心跳包，那么将其踢出服务列表。</li>
<li><code>Subscribe</code>：如果客户端订阅了某个微服务，那么客户端会在本地缓存该微服务的服务列表，并且不停地向服务端请求某个微服务的服务列表来更新本地的服务列表。没有订阅就不会本地缓存。</li>
<li><code>Push Event</code>：当客户端向服务端获取过某个微服务的服务列表后，当这个微服务的服务列表在服务端发生变化时，服务端会通过UDP向各个客户端发送消息，客户端就会根据消息去服务端拉取对应微服务的服务列表来触发对应的事件。</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkfgg8cayjj30vo0fq754.jpg" alt="image-20201106145154217" style="zoom:50%;" />



<p><strong><font size=4px>(2) 集群模式</font></strong></p>
<p>在集群模式下，Nacos与服务端的通信如下图：</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkfh57963jj31jj0u0gou.jpg" alt="image-20201106151555576" style="zoom: 50%;" />

<p>在集群模式下，Nacos客户端与服务端的通信内容还是与单机模式相同的，但是通信模式上有所区别：</p>
<ul>
<li>在Nacos集群前会添加一个网关，用于Nacos服务端集群的负载均衡，客户端仅仅需要知道网关的IP地址即可，常用的网关就是Nginx</li>
<li>负载均衡可能会让某个Nacos客户端的请求打到不同的服务器上，而每一个Nacos客户端在稳定情况下都只与一台Nacos服务器进行通信，即Nacos客户端与服务端是绑定的，如果客户端的一个请求打到了不是与它绑定的服务器上，那么该服务器会把请求转发到对应的服务器上。<ul>
<li>Nacos客户端与服务端绑定的原因是：在Distro协议下，数据的同步是异步的，如果注册服务是通过一台服务器完成的，而发送心跳是另一个服务器，那么可能接收心跳的服务器还没有把数据同步过来，因此需要绑定。</li>
</ul>
</li>
</ul>
<h2 id="集群之间的通信"><a href="#集群之间的通信" class="headerlink" title="集群之间的通信"></a>集群之间的通信</h2><p>在Ditro协议下，集群之间的通信主要是数据的同步，如下图，如果Nacos客户端发起了一个修改服务列表的请求，那么数据在一台Nacos服务器上修改了以后，会<strong>异步</strong>地将对应的服务的所有数据通过HTTP请求发送给集群中所有的机器，发送失败会进行重试，以此来更新集群中所有机器上的数据。</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkfi2pmllvj31se0u0ad0.jpg" alt="image-20201106154808045" style="zoom:50%;" />

<p>注意，这是一种弱一致性，在Nacos的一台机器接收到客户端的请求修改数据后，会马上返回结果，然后异步的向各个服务器同步数据，此时整个集群对外仍然是提供服务的，这也就意味着刚刚修改的数据，在某些机器上是最新的，而在有些机器上由于同步未完成造成数据是旧的，如果此时有客户端来进行查询，会获取到旧的数据。但由于会进行同步，集群的数据是最终一致的。</p>
<h1 id="Distro数据同步源码"><a href="#Distro数据同步源码" class="headerlink" title="Distro数据同步源码"></a>Distro数据同步源码</h1><h2 id="运行过程中的同步"><a href="#运行过程中的同步" class="headerlink" title="运行过程中的同步"></a>运行过程中的同步</h2><p>我们还是以服务注册为例子，在服务注册时，会提交一个数据同步的任务。在上一篇的源码分析中，我们知道服务注册后新的实例列表会被更新到<code>DistroConsistencyServiceImpl</code>中的<code>DataStore</code>中，是通过其<code>put</code>方法实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DistroConsistencyServiceImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    onPut(key, value);  <span class="comment">// 向dataStore中存放，并向队列中放置service改变的事件</span></span><br><span class="line">    taskDispatcher.addTask(key);    <span class="comment">// 添加数据一致性同步的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>OnPut</code>我们在上一篇中已经分析过，它是用于改变本地的数据，而第4行则是用于数据同步的：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskDispatcher</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// taskSchedulerList是一个与CPU数量有关大小的数组，是多个周期Runnable任务，意味着每个CPU执行一部分,</span></span><br><span class="line">    <span class="comment">// 每个任务中保存了一个key的queue，将key添加到queue中，任务会不停循环拿出key来进行数据同步</span></span><br><span class="line">    taskSchedulerList.get(UtilsAndCommons.shakeUp(key, cpuCoreCount)).addTask(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TaskDispatcher中定义了一个TaskScheduler的数组，TaskScheduler实现了Runnable接口，每个TaskScheduler中保存了一个Queue用来保存需要同步的服务名。TaskScheduler数组的大小与CPU的核数有关，每次addTask相当于是负责均衡了一下。</p>
<p>下面看一下TaskScheduler中执行的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class DataSyncer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskScheduler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 省略部分方法与属性</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">128</span> * <span class="number">1024</span>);	<span class="comment">// 保存需要同步的服务ID</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 取出一个需要同步的服务ID</span></span><br><span class="line">                String key = queue.poll(partitionConfig.getTaskDispatchPeriod(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Loggers.DISTRO.isDebugEnabled() &amp;&amp; StringUtils.isNotBlank(key)) &#123;</span><br><span class="line">                    Loggers.DISTRO.debug(<span class="string">&quot;got key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 集群不为空</span></span><br><span class="line">                <span class="keyword">if</span> (dataSyncer.getServers() == <span class="keyword">null</span> || dataSyncer.getServers().isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(key)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dataSize == <span class="number">0</span>) &#123;</span><br><span class="line">                    keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keys.add(key);</span><br><span class="line">                dataSize++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dataSize == partitionConfig.getBatchSyncKeyCount()</span><br><span class="line">                        || (System.currentTimeMillis() - lastDispatchTime) &gt; partitionConfig</span><br><span class="line">                        .getTaskDispatchPeriod()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (Member member : dataSyncer.getServers()) &#123;     <span class="comment">// 遍历集群的每一台机器</span></span><br><span class="line">                        <span class="keyword">if</span> (NetUtils.localServer().equals(member.getAddress())) &#123;   <span class="comment">// 如果是本机就跳过</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 设置一个同步任务</span></span><br><span class="line">                        SyncTask syncTask = <span class="keyword">new</span> SyncTask();</span><br><span class="line">                        syncTask.setKeys(keys);</span><br><span class="line">                        syncTask.setTargetServer(member.getAddress());</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (Loggers.DISTRO.isDebugEnabled() &amp;&amp; StringUtils.isNotBlank(key)) &#123;</span><br><span class="line">                            Loggers.DISTRO.debug(<span class="string">&quot;add sync task: &#123;&#125;&quot;</span>, JacksonUtils.toJson(syncTask));</span><br><span class="line">                        &#125;</span><br><span class="line">											<span class="comment">// 提交同步任务</span></span><br><span class="line">                        dataSyncer.submit(syncTask, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    lastDispatchTime = System.currentTimeMillis();</span><br><span class="line">                    dataSize = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Loggers.DISTRO.error(<span class="string">&quot;dispatch sync task failed.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TaskScheduler是一直执行的任务，当队列中有需要同步的服务，那么便会开始执行同步，取出需要同步的服务ID，向dataSyncer提交一个同步任务。根据其名称就可以知道，其是一个数据同步器，因此接下来我们需要去查看dataSyncer的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(SyncTask task, <span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If it&#x27;s a new task:</span></span><br><span class="line">    <span class="keyword">if</span> (task.getRetryCount() == <span class="number">0</span>) &#123;    <span class="comment">// SyncTask会有一个属性保存该任务的重试次数，重试次数为0说明是一个新的任务</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = task.getKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;    </span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            <span class="comment">// 将任务加入到taskMap中保存</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(taskMap.putIfAbsent(buildKey(key, task.getTargetServer()), key))) &#123;</span><br><span class="line">                <span class="comment">// associated key already exist:</span></span><br><span class="line">                <span class="keyword">if</span> (Loggers.DISTRO.isDebugEnabled()) &#123;</span><br><span class="line">                    Loggers.DISTRO.debug(<span class="string">&quot;sync already in process, key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task.getKeys().isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// all keys are removed:</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向线程池中提交数据同步的任务</span></span><br><span class="line">    GlobalExecutor.submitDataSync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 1. check the server</span></span><br><span class="line">        <span class="keyword">if</span> (getServers() == <span class="keyword">null</span> || getServers().isEmpty()) &#123;</span><br><span class="line">            Loggers.SRV_LOG.warn(<span class="string">&quot;try to sync data but server list is empty.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取所有需要同步的服务的id</span></span><br><span class="line">        List&lt;String&gt; keys = task.getKeys();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Loggers.SRV_LOG.isDebugEnabled()) &#123;</span><br><span class="line">            Loggers.SRV_LOG.debug(<span class="string">&quot;try to sync data for this keys &#123;&#125;.&quot;</span>, keys);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. get the datums by keys and check the datum is empty or not</span></span><br><span class="line">        <span class="comment">// 从dataStore中获取所有需要同步的服务的数据</span></span><br><span class="line">        Map&lt;String, Datum&gt; datumMap = dataStore.batchGet(keys);</span><br><span class="line">        <span class="keyword">if</span> (datumMap == <span class="keyword">null</span> || datumMap.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// clear all flags of this task:</span></span><br><span class="line">            <span class="comment">// 没有数据，从map中移除所有的任务然后返回</span></span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                taskMap.remove(buildKey(key, task.getTargetServer()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 序列化需要同步的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = serializer.serialize(datumMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">boolean</span> success = NamingProxy.syncData(data, task.getTargetServer());   <span class="comment">// 发起http请求，进行数据同步</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 如果失败了，重新提交任务</span></span><br><span class="line">            SyncTask syncTask = <span class="keyword">new</span> SyncTask();</span><br><span class="line">            syncTask.setKeys(task.getKeys());</span><br><span class="line">            syncTask.setRetryCount(task.getRetryCount() + <span class="number">1</span>);</span><br><span class="line">            syncTask.setLastExecuteTime(timestamp);</span><br><span class="line">            syncTask.setTargetServer(task.getTargetServer());</span><br><span class="line">            retrySync(syncTask);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// clear all flags of this task:</span></span><br><span class="line">            <span class="comment">// 数据同步成功，从map中移除所有的任务</span></span><br><span class="line">            <span class="keyword">for</span> (String key : task.getKeys()) &#123;</span><br><span class="line">                taskMap.remove(buildKey(key, task.getTargetServer()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中：</p>
<ol>
<li>判断任务是否是新的任务还是重试的任务，如果是新任务，就将任务所有的服务id保存在taskMap中，如果taskMap中已经存在了该服务id，就移除从本次的任务中移除该服务的id，避免重复的推送覆盖</li>
<li>向线程池中提交同步的任务，在该任务中，会通过任务中保存的所有的服务id从dataStore中获取到对应实例数据组成一个Map，通过http发送给集群中的其他机器。</li>
</ol>
<h2 id="集群机器启动时的同步"><a href="#集群机器启动时的同步" class="headerlink" title="集群机器启动时的同步"></a>集群机器启动时的同步</h2><p>集群中的每一台机器启动时间都可能是不一样的，有些机器先启动，有些后启动，那么有可能一台机器已经启动了并对外提供服务一段时间，而另一个才刚刚启动，此时在启动时就需要进行数据的同步，启动时的数据同步也是在<code>DistroConsistencyServiceImpl</code>中完成的。</p>
<p><code>DistroConsistencyServiceImpl</code>是通过Spring注入到容器中，其中有一个方法是标注了<code>@PostConstruct</code>，这意味着，该方法会在Bean的初始化过程中，Autowire依赖注入之后执行，被<code>@PostConstruct</code>标注的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class DistroConsistencyServiceImpl</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GlobalExecutor.submitLoadDataTask(loadDataTask);    <span class="comment">// 向线程池中提交数据同步的任务</span></span><br><span class="line">    GlobalExecutor.submitDistroNotifyTask(notifier);    <span class="comment">// 提交事件发生通知的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第2行就是提交数据同步的任务，完成从其他服务器同步数据，提交的任务如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadDataTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            load();	<span class="comment">// 进行远程加载数据</span></span><br><span class="line">            <span class="keyword">if</span> (!initialized) &#123;	<span class="comment">// initialized为false代表加载失败</span></span><br><span class="line">                <span class="comment">// 重新提交加载任务，延时执行</span></span><br><span class="line">                GlobalExecutor.submitLoadDataTask(<span class="keyword">this</span>, globalConfig.getLoadDataRetryDelayMillis());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Loggers.DISTRO.info(<span class="string">&quot;load data success&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Loggers.DISTRO.error(<span class="string">&quot;load data failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由LoadDataTaskd的run方法可以知道，集群的节点在启动时会去加载远程的数据，如果加载出现了问题或者异常，就延时再加载一次。</p>
<p>LoadDataTask的run()方法主要就是执行<code>DistroConsistencyServiceImpl</code>的<code>load</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class DistroConsistencyServiceImpl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ApplicationUtils.getStandaloneMode()) &#123;	<span class="comment">// 如果是单机启动，就不需要同步数据</span></span><br><span class="line">        initialized = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// size = 1 means only myself in the list, we need at least one another server alive:</span></span><br><span class="line">    <span class="comment">// 当集群中的机器数量只有小于或等于1时，证明集群中其他机器还未注册到本机上，不能同步数据，先睡眠重试</span></span><br><span class="line">    <span class="keyword">while</span> (memberManager.getServerList().size() &lt;= <span class="number">1</span>) &#123;	</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        Loggers.DISTRO.info(<span class="string">&quot;waiting server list init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 获取memberManager中所有的机器</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Member&gt; entry : memberManager.getServerList().entrySet()) &#123;</span><br><span class="line">        <span class="keyword">final</span> String address = entry.getValue().getAddress();</span><br><span class="line">        <span class="keyword">if</span> (ApplicationUtils.getLocalAddress().equals(address)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;	<span class="comment">// 该机器是本机，直接跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Loggers.DISTRO.isDebugEnabled()) &#123;</span><br><span class="line">            Loggers.DISTRO.debug(<span class="string">&quot;sync from &quot;</span> + address);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// try sync data from remote server:</span></span><br><span class="line">        <span class="keyword">if</span> (syncAllDataFromRemote(address)) &#123;	<span class="comment">// 同步数据</span></span><br><span class="line">            initialized = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可知加载远程数据的逻辑是：</p>
<ol>
<li>判断当前是否为单机启动，如果是单机启动，则不需要同步数据</li>
<li>等待集群中其他机器的启动并且注册到本机上</li>
<li>获取本地保存的所有集群中的机器进行遍历，如果是本机则不需同步，否则就从远程加载数据</li>
</ol>
<p>同步数据为<code>syncAllDataFromRemote</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">syncAllDataFromRemote</span><span class="params">(String server)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = NamingProxy.getAllData(server);   <span class="comment">// 通过http拉取对应服务器上的所有数据(服务列表)</span></span><br><span class="line">        <span class="keyword">return</span> processData(data);   <span class="comment">// 处理返回数据</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Loggers.DISTRO.error(<span class="string">&quot;sync full data from &quot;</span> + server + <span class="string">&quot; failed!&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中：</p>
<ol>
<li>通过http请求拉取远程的所有同步数据</li>
<li>处理返回的数据，即同步到本地</li>
</ol>
<p>调用了<code>processData</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class DistroConsistencyServiceImpl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 反序列化为服务id与其对应的实例列表</span></span><br><span class="line">        Map&lt;String, Datum&lt;Instances&gt;&gt; datumMap = serializer.deserializeMap(data, Instances.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一个服务id</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Datum&lt;Instances&gt;&gt; entry : datumMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 将其更新为新同步过来的数据，在这里，如果本机有了该key的信息就会被覆盖？会不会造成数据丢失？</span></span><br><span class="line">            <span class="comment">// 不过Nacos客户端在发送心跳时，如果发送给的服务器上面没有对应的服务实例，就会去创建一个实例加入</span></span><br><span class="line">            <span class="comment">// 猜测就算丢失了应该也没有影响，本身就是弱一致性</span></span><br><span class="line">            dataStore.put(entry.getKey(), entry.getValue());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断本地有没有该服务id，可能会有，因为从其他服务器同步数据是异步执行，</span></span><br><span class="line">            <span class="comment">// 也会从多个机器上同步过来，可能本机上被注册了服务或者同步过该服务</span></span><br><span class="line">            <span class="keyword">if</span> (!listeners.containsKey(entry.getKey())) &#123;</span><br><span class="line">                <span class="comment">// pretty sure the service not exist:</span></span><br><span class="line">                <span class="keyword">if</span> (switchDomain.isDefaultInstanceEphemeral()) &#123;    <span class="comment">// 是不是零时节点</span></span><br><span class="line">                    <span class="comment">// create empty service</span></span><br><span class="line">                    <span class="comment">// 本机上没有该服务，创建一个新的服务</span></span><br><span class="line">                    Loggers.DISTRO.info(<span class="string">&quot;creating service &#123;&#125;&quot;</span>, entry.getKey());</span><br><span class="line">                    Service service = <span class="keyword">new</span> Service();</span><br><span class="line">                    String serviceName = KeyBuilder.getServiceName(entry.getKey());</span><br><span class="line">                    String namespaceId = KeyBuilder.getNamespace(entry.getKey());</span><br><span class="line">                    service.setName(serviceName);</span><br><span class="line">                    service.setNamespaceId(namespaceId);</span><br><span class="line">                    service.setGroupName(Constants.DEFAULT_GROUP);</span><br><span class="line">                    <span class="comment">// now validate the service. if failed, exception will be thrown</span></span><br><span class="line">                    service.setLastModifiedMillis(System.currentTimeMillis());</span><br><span class="line">                    service.recalculateChecksum();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// The Listener corresponding to the key value must not be empty</span></span><br><span class="line">                    <span class="comment">// 这里的listener可能一开始获取不到，抛出异常，但是会重试，取出的listener为ServiceManager对象</span></span><br><span class="line">                    RecordListener listener = listeners.get(KeyBuilder.SERVICE_META_KEY_PREFIX).peek();</span><br><span class="line">                    <span class="keyword">if</span> (Objects.isNull(listener)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 通知ServiceManager该服务发生了变化，将该service放入ServiceManager的存储中供外部查询</span></span><br><span class="line">                    listener.onChange(KeyBuilder.buildServiceMetaKey(namespaceId, serviceName), service);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知所有监听了该服务的监听器数据发生了改变</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Datum&lt;Instances&gt;&gt; entry : datumMap.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!listeners.containsKey(entry.getKey())) &#123;</span><br><span class="line">                <span class="comment">// Should not happen:</span></span><br><span class="line">                Loggers.DISTRO.warn(<span class="string">&quot;listener of &#123;&#125; not found.&quot;</span>, entry.getKey());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (RecordListener listener : listeners.get(entry.getKey())) &#123;</span><br><span class="line">                    listener.onChange(entry.getKey(), entry.getValue().value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Loggers.DISTRO.error(<span class="string">&quot;[NACOS-DISTRO] error while execute listener of key: &#123;&#125;&quot;</span>, entry.getKey(), e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update data store if listener executed successfully:</span></span><br><span class="line">            <span class="comment">// 再put了一次，不知道为什么</span></span><br><span class="line">            dataStore.put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理数据的流程为：</p>
<ol>
<li>将Http响应回来的数据进行反序列化得到<code>Map&lt;String, Datum&lt;Instances&gt;&gt;</code>，即服务id与对应的所有实例的Map</li>
<li>遍历每一个服务id:<ol>
<li>将响应回来的该服务id的数据<code>put</code>到本地的dataStore中，此时注意有可能本地已经有了该服务id，可能会被覆盖而丢失了本地原来的数据，不过Nacos客户端完成注册后在发送心跳时，如果发送给的服务器上面没有对应的服务实例，就会去创建一个实例加入，所以覆盖了应该也没问题。</li>
<li>判断本地是否有该服务id对应的Service，如果没有，就创建一个新的Service对象</li>
<li>从所有的listener中取出key为KeyBuilder.SERVICE_META_KEY_PREFIX的listener的头一个，这listener为<code>ServiceManager</code>对象，由上一篇分析我们可以知道<code>ServiceManager</code>是管理namespace-service-cluster-instance这样一个关系的管理器，外部需要查询数据时，会到<code>ServiceManager</code>中查，<code>ConsistencyService</code>中的dataStore仅仅是用于做数据同步的，调用<code>ServiceManager</code>的<code>onChange</code>方法便会将新创建的Service加入到其服务列表中。</li>
</ol>
</li>
<li>通知监听了每一个同步过来的服务id的观察者，执行onChange方法，并且dataStore再执行一次put方法。</li>
</ol>
<p>到此即完成了集群节点启动时远程数据的拉取。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Nacos源码(3)-Distro数据同步</p><p><a href="http://example.com/2020/11/06/Nacos%E6%BA%90%E7%A0%81(3)-Distro%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/">http://example.com/2020/11/06/Nacos%E6%BA%90%E7%A0%81(3)-Distro%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>tomcode</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-11-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-11-08</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/nacos/">nacos</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/19/JAVA%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JAVA并发-线程池之ThreadPoolExecutor</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/11/05/JAVA%E5%B9%B6%E5%8F%91-AQS/"><span class="level-item">JAVA并发-AQS</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://gitee.com/leizz1/pictures/raw/master/null/AF32230B-6341-40A5-BADE-7C898E5E858B(20190701-101.JPG" alt="tomcode"></figure><p class="title is-size-4 is-block line-height-inherit">tomcode</p><p class="is-size-6 is-block">努力努力再努力</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MrZhangL" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget is-sticky" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#Nacos通信架构"><span class="mr-2">1</span><span>Nacos通信架构</span></a><ul class="menu-list"><li><a class="is-flex" href="#客户端与服务通信"><span class="mr-2">1.1</span><span>客户端与服务通信</span></a></li><li><a class="is-flex" href="#集群之间的通信"><span class="mr-2">1.2</span><span>集群之间的通信</span></a></li></ul></li><li><a class="is-flex" href="#Distro数据同步源码"><span class="mr-2">2</span><span>Distro数据同步源码</span></a><ul class="menu-list"><li><a class="is-flex" href="#运行过程中的同步"><span class="mr-2">2.1</span><span>运行过程中的同步</span></a></li><li><a class="is-flex" href="#集群机器启动时的同步"><span class="mr-2">2.2</span><span>集群机器启动时的同步</span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/JAVA/"><span class="level-start"><span class="level-item">JAVA</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="level-start"><span class="level-item">Java多线程</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Netty/"><span class="level-start"><span class="level-item">Netty</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SSM/"><span class="level-start"><span class="level-item">SSM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-19T04:55:12.000Z">2020-11-19</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/19/JAVA%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor/">JAVA并发-线程池之ThreadPoolExecutor</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-06T11:24:35.000Z">2020-11-06</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/06/Nacos%E6%BA%90%E7%A0%81(3)-Distro%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/">Nacos源码(3)-Distro数据同步</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-05T07:24:35.000Z">2020-11-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/11/05/JAVA%E5%B9%B6%E5%8F%91-AQS/">JAVA并发-AQS</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-30T13:51:55.000Z">2020-10-30</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/30/Nacos%E6%BA%90%E7%A0%81(2)-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B/">Nacos源码(2)-服务注册流程</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-29T10:16:35.000Z">2020-10-29</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/29/Nacos%E6%BA%90%E7%A0%81(1)-Nacos%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%BA%90%E7%A0%81%E5%90%AF%E5%8A%A8/">Nacos源码(1)-Nacos服务端源码启动</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nacos/"><span class="tag">nacos</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/netty/"><span class="tag">netty</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">5</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a><p class="size-small"><span>&copy; 2020 tomcode</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>