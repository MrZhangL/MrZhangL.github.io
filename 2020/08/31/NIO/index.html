<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Netty核心组件-NIO - MrZhang</title><meta description="NIO（JDK1.4）模型是一种同步非阻塞IO，主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector（多路复用器）。"><meta property="og:type" content="blog"><meta property="og:title" content="Netty核心组件-NIO"><meta property="og:url" content="http://example.com/2020/08/31/NIO/"><meta property="og:site_name" content="MrZhang"><meta property="og:description" content="NIO（JDK1.4）模型是一种同步非阻塞IO，主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector（多路复用器）。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gf6uv76tjuj31g60aujsz.jpg"><meta property="og:image" content="https://gitee.com/leizz1/pictures/raw/master/null/image-20200902113734463.png"><meta property="og:image" content="https://gitee.com/leizz1/pictures/raw/master/null/image-20200520160533636.png"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gienbxsqkmj310g0nwmy4.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gieorgyb8jj311n0u041s.jpg"><meta property="og:image" content="https://gitee.com/leizz1/pictures/raw/master/null/image-20200908145048951.png"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gifoawvmb8j31fy07odgk.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gifod9p6kej31fs05cwf4.jpg"><meta property="og:image" content="https://gitee.com/leizz1/pictures/raw/master/null/image-20200908143202444.png"><meta property="article:published_time" content="2020-08-31T12:31:15.000Z"><meta property="article:modified_time" content="2020-09-08T11:16:34.387Z"><meta property="article:author" content="tomcode"><meta property="article:tag" content="netty"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gf6uv76tjuj31g60aujsz.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/08/31/NIO/"},"headline":"MrZhang","image":["https://tva1.sinaimg.cn/large/007S8ZIlly1gf6uv76tjuj31g60aujsz.jpg","https://gitee.com/leizz1/pictures/raw/master/null/image-20200902113734463.png","https://gitee.com/leizz1/pictures/raw/master/null/image-20200520160533636.png","https://tva1.sinaimg.cn/large/007S8ZIlly1gienbxsqkmj310g0nwmy4.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gieorgyb8jj311n0u041s.jpg","https://gitee.com/leizz1/pictures/raw/master/null/image-20200908145048951.png","https://tva1.sinaimg.cn/large/007S8ZIlly1gifoawvmb8j31fy07odgk.jpg","https://tva1.sinaimg.cn/large/007S8ZIlly1gifod9p6kej31fs05cwf4.jpg","https://gitee.com/leizz1/pictures/raw/master/null/image-20200908143202444.png"],"datePublished":"2020-08-31T12:31:15.000Z","dateModified":"2020-09-08T11:16:34.387Z","author":{"@type":"Person","name":"tomcode"},"description":"NIO（JDK1.4）模型是一种同步非阻塞IO，主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector（多路复用器）。"}</script><link rel="canonical" href="http://example.com/2020/08/31/NIO/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-08-31T12:31:15.000Z" title="2020-08-31T12:31:15.000Z">2020-08-31</time>发表</span><span class="level-item"><time dateTime="2020-09-08T11:16:34.387Z" title="2020-09-08T11:16:34.387Z">2020-09-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Netty/">Netty</a></span><span class="level-item">24 分钟读完 (大约3565个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Netty核心组件-NIO</h1><div class="content"><p>NIO（JDK1.4）模型是一种同步非阻塞IO，主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector（多路复用器）。<a id="more"></a></p>
<h1 id="1-Buffer"><a href="#1-Buffer" class="headerlink" title="1 Buffer"></a>1 Buffer</h1><h2 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h2><p>Buffer的本质就是一个存放数据内存块，可以看成一个容器对象(内部含有数组)，该对象提供了一系列方法，能让我们轻松的使用内存块(数组)，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf6uv76tjuj31g60aujsz.jpg" alt="image-20200520152951636" style="zoom: 33%;" />

<p>JDK中Buffer的子类如下：</p>
<img src="https://gitee.com/leizz1/pictures/raw/master/null/image-20200902113734463.png" alt="image-20200902113734463" style="zoom: 33%;" />



<p>首先，Buffer都具有4个重要属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/leizz1/pictures/raw/master/null/image-20200520160533636.png" alt="image-20200520160533636" style="zoom: 33%;" />



<p>Buffer分为读模式和写模式，一次读操作或写操作都可能会导致position后移(可能即为JDK提供了不同的方法，有读操作后position后移的方法，也有读操作后position不后移的方法)：</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gienbxsqkmj310g0nwmy4.jpg" alt="写模式 v.s. 读模式" style="zoom:50%;" />



<p>Buffer的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntBuffer buffer = IntBuffer.allocate(<span class="number">5</span>);		<span class="comment">// postion=0, capacity=5, limit=5, mark=-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            buffer.put(i*<span class="number">2</span>);    <span class="comment">// 每次put后position属性+1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer.flip();  			 <span class="comment">// 将position重置到0</span></span><br><span class="line">        buffer.position(<span class="number">1</span>);  	<span class="comment">// 将position置为1</span></span><br><span class="line">        buffer.limit(<span class="number">3</span>);     	<span class="comment">// 将limit置为3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(buffer.get());   <span class="comment">// 每次get()都会导致postion+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-HeapBuffer和DirectByteBuffer"><a href="#1-2-HeapBuffer和DirectByteBuffer" class="headerlink" title="1.2 HeapBuffer和DirectByteBuffer"></a>1.2 HeapBuffer和DirectByteBuffer</h2><p>​    HeapBuffer被称为No-DirectBuffer，这一缓冲区创建在JVM内存的堆区中，受到JVM的内存管理，创建和释放都是由JVM操作的。上面通过allocate方法创建的Buffer就是HeapBuffer。</p>
<p>​    利用HeapBuffer读取数据的过程如下：</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gieorgyb8jj311n0u041s.jpg" alt="image-20200904161315104" style="zoom: 50%;" />

<p>​    Java程序向操作系统发起read()的系统调用，操作系统让CPU启动DMA来将物理磁盘中的数据读取到内核地址空间中的缓冲区，然后再将缓冲区中的内容拷贝到用户地址空间的Buffer对象中。在这过程中发生了一次从内核地址空间到用户地址空间的拷贝。由于HeapBuffer需要经过一次拷贝，其与BIO的文件操作代价相同，效率相差不多，但下面介绍的DirectByteBuffer效率更高。</p>
<p>​    针对如上HeapBuffer的一次拷贝进行优化，DirectByteBuffer是创建在堆外内存区的，即不受JVM的内存管理机制所控制，那么为什么DirectByteBuffer可以减少这一次拷贝呢？</p>
<p>​    这要归功于<code>mmap()</code>的系统调用，这种方式的I/O原理就是将用户缓冲区（user buffer）的内存地址和内核缓冲区（kernel buffer）的内存地址做一个映射，也就是说系统将内核地址空间的缓冲区和用户地址空间的缓冲区映射物理内存上的相同位置，这样一来就可避免了从内核空间向地址空间的拷贝消耗。</p>
<img src="https://gitee.com/leizz1/pictures/raw/master/null/image-20200908145048951.png" alt="image-20200908145048951" style="zoom:50%;" />





<p>在HeapBuffer中，内核地址空间的缓冲采用的就是DirectByteBuffer，然后再把DirectBuffer中的数据拷贝到HeapBuffer中。通过跟踪ByteBuffer的源码可以查看到其read()方法调用到了IOUtil的read()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(FileDescriptor fd, ByteBuffer dst, <span class="keyword">long</span> position,</span></span></span><br><span class="line"><span class="function"><span class="params">                NativeDispatcher nd)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dst.isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Read-only buffer&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dst <span class="keyword">instanceof</span> DirectBuffer)</span><br><span class="line">        <span class="keyword">return</span> readIntoNativeBuffer(fd, dst, position, nd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Substitute a native buffer</span></span><br><span class="line">    ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining());		<span class="comment">// 获得一个临时的DirectBuffer</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = readIntoNativeBuffer(fd, bb, position, nd);		<span class="comment">// 使用native方法利用DirectBuffer进行读取</span></span><br><span class="line">        bb.flip();</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            dst.put(bb);		<span class="comment">// 将DirectBuffer读取到的数据放入到ByteBuffer中</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Util.offerFirstTemporaryDirectBuffer(bb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectBuffer可以通过ByteBuffer.allocateDirect(int len)来进行申请。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);	<span class="comment">// 申请出来为DirectByteBuffer对象</span></span><br></pre></td></tr></table></figure>



<h2 id="1-3-DirectBuffer详解说明"><a href="#1-3-DirectBuffer详解说明" class="headerlink" title="1.3 DirectBuffer详解说明"></a>1.3 DirectBuffer详解说明</h2><ol>
<li><strong>Java中申请的DirectBuffer存在的内存区域究竟是内核地址空间还是用户地址空间呢？</strong></li>
</ol>
<p>​    DirectBuffer(以DirectByteBuffer为例)其实分为两部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		 Java        |      <span class="keyword">native</span></span><br><span class="line">                  |</span><br><span class="line">DirectByteBuffer  |     malloc<span class="string">&#x27;d</span></span><br><span class="line"><span class="string">[    address   ] -+-&gt; [   data    ]</span></span><br><span class="line"><span class="string">                  |</span></span><br></pre></td></tr></table></figure>

<pre><code> 一部分为Java的堆内对象，DirectByteBuffer没有byte数组，但是有一个long address的属性，该属性在Buffer类中有，官方注释说明只用于DirectBuffer才有效：</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used only by direct buffers</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> hoisted here for speed in JNI GetDirectBufferAddress</span></span><br><span class="line">    <span class="keyword">long</span> address;</span><br></pre></td></tr></table></figure>

<p>​    另一部分为利用c语言的malloc申请的字节数组，该数据就是缓冲区，该缓冲区是用C语言API申请的，属于该进程，位于<code>用户地址空间</code>，只不过操作系统该部分内存有读写的权利，不需要经过内核地址空间的拷贝。</p>
<p>​    DirectBuffer的主要缓冲区属于堆外内存，其生命周期不完全被JVM管制，因此使用需要谨慎，必须使用Full GC才能进行回收，但是Full GC的性能损耗很大，因此合理使用DirectBuffer才能有更高的效率，Netty封装了DirectBuffer比DirectBuffer更好用。</p>
<ol start="2">
<li><strong>为什么DirectBuffer要在堆外申请，不能申请在堆内或者直接使用HeapBuffer进行mmap内存映射吗？</strong></li>
</ol>
<p>​    JVM并不是不能直接用java HeapBuffer或java byte[]直接做IO读写，但<code>JVM在GC过程中会移动内存</code>，JVM移动内存的操作对操作系统是不可见的，因此必须mark此段内存不能移动，从而影响GC效率，所有采用堆外内存更为合适。</p>
<p>​    Java利用HeapBuffer进行IO操作时都会使用到临时的DirectByteBuffer缓冲区。</p>
<ol start="3">
<li><strong>性能说明</strong></li>
</ol>
<p>​     对于文件的读写，使用FileChannel的read或write方法无论传入的是HeapBuffer还是DirectBuffer都是会创建一个临时的DirectBuffer，所以效率是相同的。想要有更高的性能使用MappedByteBuffer就不会进行内核空间到用户空间的拷贝了。</p>
<p>MappedByteBuffer使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">&quot;pom.xml&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">    FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">&quot;pom2.xml&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件的缓冲空间</span></span><br><span class="line">    MappedByteBuffer mappedByteBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">    outChannel.write(mappedByteBuffer);</span><br><span class="line"></span><br><span class="line">    inChannel.close();</span><br><span class="line">    outChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gifoawvmb8j31fy07odgk.jpg" alt="image-20200905124256759" style="zoom: 50%;" />

<p>​    由于JDK没有提供直接将DirectBuffer写到文件中的方法，因此还是需要一次拷贝的。</p>
<p>普通NIO文件拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nioFileCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">&quot;pom.xml&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">    FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">&quot;pom2.xml&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate((<span class="keyword">int</span>) inChannel.size());</span><br><span class="line">    buf.flip();</span><br><span class="line">    outChannel.write(buf);</span><br><span class="line"></span><br><span class="line">    inChannel.close();</span><br><span class="line">    outChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gifod9p6kej31fs05cwf4.jpg" alt="image-20200905124512754"></p>
<p>​    相比MappedByyeBuffer多了一次拷贝。</p>
<h1 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2 Channel"></a>2 Channel</h1><p>NIO的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>
</ul>
<p>JDK提供的Channel类型有很多，常用的有FileChannel(文件读写通道)、DatagramChannel(UDP数据传输通道)、ServerSocketChannel 和 SocketChannel (ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket，TCPS数据传输)。</p>
<p>FileChannel类：</p>
<p>用于对本地文件的读写操作，主要的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> 	<span class="comment">//从通道读取数据并放到缓冲区中</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> 	<span class="comment">//把缓冲区的数据写到通道中</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferFrom</span><span class="params">(ReadableByteChannel src, <span class="keyword">long</span> position, <span class="keyword">long</span> count)</span>		<span class="comment">//从目标通道中复制数据到当前通道</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span>		<span class="comment">//把数据从当前通道复制给目标通道</span></span></span><br></pre></td></tr></table></figure>



<p>实例–使用FileChannel实现文本的拷贝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建文件对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/zhanglei/java/IdeaProjects/netty/src/main/java/com/tomcode/nio/LearnChannel.java&quot;</span>);</span><br><span class="line">        File target = <span class="keyword">new</span> File(<span class="string">&quot;j.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建流对象</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(target);</span><br><span class="line">        <span class="comment">// 获取channel，channel需要从流对象中获取，流对象中具有channel属性但是为空，当调用getChannel时会创建channel对象</span></span><br><span class="line">        FileChannel inputChannel = fileInputStream.getChannel();</span><br><span class="line">        FileChannel outputChannel = fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">// 创建缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        <span class="comment">// 把inputchannel中的数据写到buffer中然后把buffer写到outputchannel</span></span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = inputChannel.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            outputChannel.write(buffer);</span><br><span class="line">            buffer.clear();								<span class="comment">// 必须clear()，否则postion=limit无法再读入数据，每次len=0陷入死循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 流对象关闭channel就会关闭</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同样，我们可以使用transferFrom就可以直接完成拷贝而不需要使用缓冲区了(其实底层也是利用了缓冲区)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputChannel.transferFrom(inputStream);</span><br></pre></td></tr></table></figure>



<p>使用Channel和Buffer的注意事项</p>
<ul>
<li>ByteBuffer 支持类型化的put 和 get, put放入的是什么数据类型，get就应该使用相应的数据类型来取出，否则可能有BufferUnderflow-Exception 异常。(putInt–getInt，putChar–getChar) </li>
</ul>
<ul>
<li><p>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进行修改，效率很高。</p>
</li>
<li><p>前面我们讲的读写操作，都是通过一个Buffer 完成的，NIO 还支持 通过多个Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering </p>
</li>
</ul>
<h1 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3 Selector"></a>3 Selector</h1><p>Selector选择器，作用是用于管理多个Channel，使用Selector实现IO多路复用，通常一个线程有一个Selector，而一个Selector对应多个Channel负责I/O，其工作的主要步骤：</p>
<p>(1) 在服务器启动时，创建ServerSocketChannel并利用SelectionKey register(Selector sel, int ops)方法注册到Selector中，每个channel在一个Selector中对应一个的SelectionKey。</p>
<p>(2) 在循环中调用Selector的int select()方法来判断是Selector中是否有Channel需要处理(返回值为需要处理的channel数量)，注意select()方法是阻塞的，想要非阻塞可以调用select(int timeout)或selectNow()。         </p>
<p>(3) 每当一个客户端需要连接服务器时，Selector的select方法会返回1，此时表明有channel发生了事件需要处理，那么就通过Selector的selectKeys()方法获取到所有事件的SelectionKey，可以通过SelectionKey判断其对应的是否为ServerSocketChannel，如果是则调用其accept()方法(不会阻塞，因为已经判断出有客户端要连接)。</p>
<p>(4) 通过ServerSocketChannel的accept方法都能获取到一个SocketChannel，将这个SocketChannel注册到Selector中。</p>
<p>(5) 回到(2)的循环，去判断各个channel是否有事件发生，有的话通过SocketChannel和ServerSocketChannel分开处理，ServerSocketChannel有事件就获取SocketChannel注册到Selector，SocketChannel有时间就读写。</p>
<img src="https://gitee.com/leizz1/pictures/raw/master/null/image-20200908143202444.png" alt="image-20200908143202444" style="zoom: 50%;" />



<p>实例–使用Selector来实现服务端：</p>
<p>server端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorLearn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        server.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置Channel为非阻塞的</span></span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 将server注册到selector，为ACCEPT操作，ServerSocketChannel才为该方式</span></span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 等待获取200ms，没有事件</span></span><br><span class="line">                System.out.println(<span class="string">&quot;1s没有事件&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;event!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取并遍历有事件发生的SelectionKey</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// 证明是ServerSocketChannel，获取对应的SocketChannel</span></span><br><span class="line">                    SocketChannel socket = server.accept();</span><br><span class="line">                    socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 向selector注册socket，为读操作事件(因为建立连接不一定马上有数据传输)</span></span><br><span class="line">                    socket.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// 证明是SocketChannel</span></span><br><span class="line">                    SocketChannel socket = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buf = (ByteBuffer) key.attachment();</span><br><span class="line">                    socket.read(buf);</span><br><span class="line"></span><br><span class="line">                    String content = <span class="keyword">new</span> String(buf.array());</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到:&quot;</span> + content);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理必须从集合中移除，否则会重复处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li>一个Selector可以注册多个Channel，也可以注册不同种类的Channel（SocketChannel/ServerSocketChannel），每个Channel在注册到某个Selector上时会生成一个SelectionKey对象，里面保存了Channel，Selector以后选择的就是SelectionKey对象，<strong>SelectionKey与Channel一一对应</strong>。</li>
<li>当调用了Selector的selectKeys方法后，如果此时ServerSocketChannel有多个连接请求，在调用accept后也只会连接一个，然后再循环时因为还有连接未处理则ServerSocketChannel还是有事件，接着就可以处理下一个连接。那么还未被accept的连接都会存储在操作系统的一个连接队列中等待应用程序处理。</li>
</ul>
<p><strong>Selector：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">selector.select();						<span class="comment">//阻塞</span></span><br><span class="line">selector.select(<span class="number">1000</span>);				<span class="comment">//阻塞1000毫秒，在1000毫秒后返回</span></span><br><span class="line">selector.wakeup();						<span class="comment">//唤醒selector</span></span><br><span class="line">selector.selectNow();					<span class="comment">//不阻塞，立马返还</span></span><br><span class="line"></span><br><span class="line">selector.selectedKeys();			<span class="comment">// 当前有事件发生的SelectionKey</span></span><br><span class="line">selector.keys();							 <span class="comment">// selector中注册的所有SelectionKey</span></span><br></pre></td></tr></table></figure>



<p><strong>SelectionKey：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OP_ACCEPT：有新的网络连接可以 accept，值为 <span class="number">16</span></span><br><span class="line"><span class="keyword">int</span> OP_CONNECT：代表连接已经建立，值为 <span class="number">8</span></span><br><span class="line"><span class="keyword">int</span> OP_READ：代表读操作，值为 <span class="number">1</span> </span><br><span class="line"><span class="keyword">int</span> OP_WRITE：代表写操作，值为 <span class="number">4</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title">selector</span><span class="params">()</span></span>;									 <span class="comment">//得到与之关联的 Selector 对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">channel</span><span class="params">()</span></span>;							 <span class="comment">//得到与之关联的通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">attachment</span><span class="params">()</span></span>;										<span class="comment">//得到与之关联的共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;	 					 <span class="comment">//设置或改变监听事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isAcceptable</span><span class="params">()</span></span>;									<span class="comment">//是否可以 accept</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span></span>;										<span class="comment">//是否可以读</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span></span>;										<span class="comment">//是否可以写</span></span><br></pre></td></tr></table></figure>



<p><strong>ServerSocketChannel：</strong></p>
<p>ServerSocketChannel 在服务器端监听新的客户端 Socket 连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span></span>;																	 <span class="comment">// 得到一个 ServerSocketChannel 通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span></span>;							 <span class="comment">// 设置服务器端端口号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>;  		  <span class="comment">// 设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span></span>;																						 <span class="comment">// 接受一个连接，返回代表这个连接的通道对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span></span>;							<span class="comment">// 注册一个选择器并设置监听事件</span></span><br></pre></td></tr></table></figure>



<p><strong>SocketChannel：</strong></p>
<p>SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span></span>;<span class="comment">//得到一个 SocketChannel 通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>;<span class="comment">//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span></span>;<span class="comment">//连接服务器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span></span>;<span class="comment">//如果上面的方法连接失败，接下来就要通过该方法完成连接操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span></span>;<span class="comment">//往通道里写数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span></span>;<span class="comment">//从通道里读数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span>;<span class="comment">//注册一个选择器并设置监听事件，最后一个参数可以设置共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//关闭通道</span></span><br></pre></td></tr></table></figure>











</div><div class="article-licensing box"><div class="licensing-title"><p>Netty核心组件-NIO</p><p><a href="http://example.com/2020/08/31/NIO/">http://example.com/2020/08/31/NIO/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>tomcode</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-08-31</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-09-08</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/netty/">netty</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/09/01/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ByteBuf/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Netty核心组件-ByteBuf</span></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://gitee.com/leizz1/pictures/raw/master/null/AF32230B-6341-40A5-BADE-7C898E5E858B(20190701-101.JPG" alt="tomcode"></figure><p class="title is-size-4 is-block line-height-inherit">tomcode</p><p class="is-size-6 is-block">努力努力再努力</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MrZhangL" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget is-sticky" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#1-Buffer"><span class="mr-2">1</span><span>1 Buffer</span></a><ul class="menu-list"><li><a class="is-flex" href="#1-1-基本使用"><span class="mr-2">1.1</span><span>1.1 基本使用</span></a></li><li><a class="is-flex" href="#1-2-HeapBuffer和DirectByteBuffer"><span class="mr-2">1.2</span><span>1.2 HeapBuffer和DirectByteBuffer</span></a></li><li><a class="is-flex" href="#1-3-DirectBuffer详解说明"><span class="mr-2">1.3</span><span>1.3 DirectBuffer详解说明</span></a></li></ul></li><li><a class="is-flex" href="#2-Channel"><span class="mr-2">2</span><span>2 Channel</span></a></li><li><a class="is-flex" href="#3-Selector"><span class="mr-2">3</span><span>3 Selector</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Netty/"><span class="level-start"><span class="level-item">Netty</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-08T07:57:22.000Z">2020-09-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/08/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ChannelFuture/">Netty核心组件-ChannelFuture</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-01T12:17:51.000Z">2020-09-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/01/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ByteBuf/">Netty核心组件-ByteBuf</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-31T12:31:15.000Z">2020-08-31</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/31/NIO/">Netty核心组件-NIO</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Netty/">Netty</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/netty/"><span class="tag">netty</span><span class="tag is-grey-lightest">3</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a><p class="size-small"><span>&copy; 2020 tomcode</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>