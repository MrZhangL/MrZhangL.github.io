<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MrZhang</title><meta property="og:type" content="blog"><meta property="og:title" content="MrZhang"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="MrZhang"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="tomcode"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"MrZhang","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"tomcode"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/xcode.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-10-30T13:51:55.000Z" title="2020-10-30T13:51:55.000Z">2020-10-30</time>发表</span><span class="level-item"><time dateTime="2020-10-31T07:13:16.865Z" title="2020-10-31T07:13:16.865Z">2020-10-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><span class="level-item">22 分钟读完 (大约3374个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/30/Nacos%E6%BA%90%E7%A0%81-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B/">Nacos源码-服务注册流程</a></h1><div class="content"><p>Nacos一个重要的作用就是用作微服务的注册中心，各个微服务向Nacos注册，并且从Nacos拉取自己所需要的其他微服务，因此学习一下Nacos的服务注册流程。</p>
<h1 id="客户端的服务发现与注册"><a href="#客户端的服务发现与注册" class="headerlink" title="客户端的服务发现与注册"></a>客户端的服务发现与注册</h1><p>Nacos的服务注册采用的是HTTP请求，通过官网的描述，我们可以直接通过一个Http请求来注册我们的服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">&#x27;http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过一个post请求，我们就可以将服务注册到Nacos上，但是，不推荐直接发起Http请求来注册服务，因为注册服务的过程远远比单纯发起一个HTTP请求复杂，Nacos提供了与服务端交互的客户端，位于源码中的<code>nacos-client</code>模块。在Spring Cloud中，Nacos作为注册模块采用的就是<code>nacos-client</code></p>
<p>，我们从Spring Cloud中入手来了解Nacos如何在项目启动时完成服务的注册。</p>
<p>SpringCloud只是向外开发了一套自动注册的标准，而自动注册的功能是需要开发者去提供了，Nacos、Eureka等注册中心，都是针对了SpringCloud做了适配，实现自动注册，因此我们的目光不能只放在SpringCloud上了。对于SpringBoot、SpirngCloud而言，都是通过注解实现自动配置，大多数组件的注入都是通过XXXAutoConfiguration来实现，因此我们查找一下是否有关于Nacos的AutoConfiguration，经过搜索，确实有一个叫<code>NacosDiscoveryAutoConfiguration</code>，看到这个名字，我们就可以推断，这个类就是用于Nacos服务发现的自动配置：</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk75bng47cj31g50u0wq8.jpg" alt="image-20201030102224900" style="zoom: 67%;" />



<p>通过上面的代码我们可以知道，Nacos自动配置类生效依赖于<code>ServiceRegistryAutoConfiguration</code>和<code>AutoServiceRegistrationAutoConfiguration</code>两个配置类的生效，这两个类都是<code>Spring Cloud</code>提供的，也就是说这两个类是SpringCloud提供的服务发现与注册的标准，只有这两个配置类生效，才允许进行服务注册与发现，只要导入了Spring Cloud依赖，那么这两个类将通过SPI自动注入到容器中，这两个类配置在<code>spring-cloud-commons</code>的项目下<code>spring.factories</code>文件下：</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk75xroviyj31he0u0gug.jpg" alt="image-20201030104340441" style="zoom: 50%;" />

<p>也就是说当我们引入spring-cloud-alibaba-nacos-discovery的依赖时，同时也会引入spring-cloud-commons，会自动向容器中注册这两个类，那么Nacos的自动配置类也能够生效。我们在回到<code>NacosDiscoveryAutoConfiguration</code>中，该配置类向容器中注入了三个Bean对象，分别为：</p>
<ul>
<li>NacosServiceRegistry：该Bean是注册中心的客户端，用于与注册中心Nacos交互，例如注册服务，拉取服务、心跳续约等，该类实现了SpringCloud提供的<code>ServiceRegistry</code>接口。</li>
<li>NacosRegistration：该Bean是从application.yml/properties配置文件中加载当前微服务的一些信息，封装为Nacos需要的服务注册的信息。该类实现了SpringCloud提供的<code>Registration</code>与<code>ServiceInstance</code>接口</li>
<li>NacosAutoServiceRegistration：该Bean实现了服务的自动注册与发现，利用NacosServiceRegistry与NacosRegistration将当前的微服务注册到Naocs上。该类继承了SpringCloud提供的<code>AbstractAutoServiceRegistration</code>类</li>
</ul>
<p>前两个Bean对象都很好理解，自动注册的代码主要在<code>NacosAutoServiceRegistration</code>中实现。</p>
<p>SpringCloud针对服务的自动注册也提供了一套标准，那就是<code>AbstractAutoServiceRegistration</code>：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk76cjnxxyj315i04475e.jpg" alt="image-20201030105753006"></p>
<p>特别注意的是，该类实现了<code>ApplicationListener&lt;WebServerInitializedEvent&gt;</code>，实现了该类的类，如果注入到容器中，那么在Web容器初始化结束后，自动调用其接口的<code>void onApplicationEvent(E event);</code>方法。我们也可以估计到，服务的自动注册与发现就是通过该方法实现的，查看<code>AbstractAutoServiceRegistration</code>的该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoServiceRegistration</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">   bind(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">   ApplicationContext context = event.getApplicationContext();</span><br><span class="line">   <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableWebServerApplicationContext) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;management&quot;</span>.equals(((ConfigurableWebServerApplicationContext) context)</span><br><span class="line">            .getServerNamespace())) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.port.compareAndSet(<span class="number">0</span>, event.getWebServer().getPort());</span><br><span class="line">   <span class="keyword">this</span>.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Discovery Lifecycle disabled. Not starting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// only initialize if nonSecurePort is greater than 0 and it isn&#x27;t already running</span></span><br><span class="line">  <span class="comment">// because of containerPortInitializer below</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.running.get()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.context.publishEvent(</span><br><span class="line">      <span class="keyword">new</span> InstancePreRegisteredEvent(<span class="keyword">this</span>, getRegistration()));	<span class="comment">// 向容器中发布即将服务注册的事件</span></span><br><span class="line">    register();		<span class="comment">// 完成服务注册</span></span><br><span class="line">    <span class="keyword">if</span> (shouldRegisterManagement()) &#123;</span><br><span class="line">      registerManagement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.context.publishEvent(</span><br><span class="line">      <span class="keyword">new</span> InstanceRegisteredEvent&lt;&gt;(<span class="keyword">this</span>, getConfiguration()));  <span class="comment">// 向容器中发布服务注册完成的事件</span></span><br><span class="line">    <span class="keyword">this</span>.running.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.serviceRegistry.register(getRegistration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>onApplicationEvent</code>方法的调用链，一直到start()方法，在该方法中，在服务注册的前后都向Spring容器中发布了服务注册前/后的事件，<code>register()</code>方法是向注册中心注册微服务，而有调用了serviceRegistry的<code>register(R registration)</code>方法，该方法便是将服务的服务的注册信息注册到注册中心。</p>
<p>我们需要注意，在Nacos的自动配置类中，向容器中自动注入了<code>AbstractAutoServiceRegistration</code>的子类<code>NacosAutoServiceRegistration</code>，而<code>NacosAutoServiceRegistration</code>在初始化的时候，传入了<code>NacosServiceRegistry</code>和<code>NacosRegistration</code>。这样就非常的清晰明了，在调用下面这句话时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.serviceRegistry.register(getRegistration());</span><br></pre></td></tr></table></figure>

<p>serviceRegistry即为<code>NacosServiceRegistry</code>对象，getRegistration()放回的就是<code>NacosRegistration</code></p>
<p>经过验证：</p>
<p>在<code>AbstractAutoServiceRegistration</code>中，<code>getRegistration()</code>方法是一个抽象方法，该方法将由其子类实现完成服务注册，我们使用的是Nacos，在实现中，返回的就是在初始化时传入到<code>AbstractAutoServiceRegistration</code>中的<code>NacosRegistration</code>。</p>
<p>现在我们就可以来看<code>NacosServiceRegistry</code>的registry()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Registration registration)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.isEmpty(registration.getServiceId())) &#123;</span><br><span class="line">      log.warn(<span class="string">&quot;No service to register for nacos client...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String serviceId = registration.getServiceId();</span><br><span class="line"></span><br><span class="line">   Instance instance = getNacosInstanceFromRegistration(registration);	<span class="comment">// 转化为Nacos的Instance类</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      namingService.registerInstance(serviceId, instance);	<span class="comment">// 注册到Nacos</span></span><br><span class="line">      log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, serviceId,</span><br><span class="line">            instance.getIp(), instance.getPort());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;nacos registry, &#123;&#125; register failed...&#123;&#125;,&quot;</span>, serviceId,</span><br><span class="line">            registration.toString(), e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中通过<code>namingService.registerInstance(serviceId, instance);</code>完成服务注册，namingService是<code>nacos-client</code>提供的与服务端互交的客户端对象，主要用于给Nacos服务端发起Http请求并且如果是临时节点将保持心跳。</p>
<h1 id="服务端服务注册"><a href="#服务端服务注册" class="headerlink" title="服务端服务注册"></a>服务端服务注册</h1><p>Nacos服务端本身也是一个Springboot项目，向Nacos服务端发起Http请求就能注册服务，因此我们需要找到Controller中能够接收服务注册的某个方法，我们通过客户端的代码可以看到注册服务的url地址是<code>/nacos/v1/ns/instance</code>，因此我们在相关的Controller中找到该url的方法，位于nacos-namming模块下的InstanceController的register方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanDistro</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);</span><br><span class="line">    <span class="keyword">final</span> String namespaceId = WebUtils</span><br><span class="line">            .optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Instance instance = parseInstance(request);</span><br><span class="line">    </span><br><span class="line">    serviceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>serviceManager用于管理所有的Service，在阅读源码前，我们有必要先了解一下ServiceManager的组成：</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk7olgl8gbj31d80pqmz0.jpg" alt="image-20201030212911284" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceManager中保存了</span></span><br><span class="line">Map&lt;String, Map&lt;String, Service&gt;&gt; serviceMap;		<span class="comment">// namespace:(serviceName:Service)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于每个Service中保存了</span></span><br><span class="line">Map&lt;String, Cluster&gt; clusterMap;	<span class="comment">// clusterName:Cluster</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个Cluster中保存了</span></span><br><span class="line">Set&lt;Instance&gt; persistentInstances;	<span class="comment">// 持久节点</span></span><br><span class="line">Set&lt;Instance&gt; ephemeralInstances;		<span class="comment">// 临时节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceManager保存了</span></span><br><span class="line">ConsistencyService consistencyService;</span><br><span class="line"><span class="comment">// ConsistencyService保存了一个Datastore</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DataStore dataStore;</span><br><span class="line"><span class="comment">// dataStore保存了</span></span><br><span class="line">Map&lt;String, Datum&gt; dataMap;</span><br><span class="line"><span class="comment">// Datum保存了</span></span><br><span class="line"><span class="keyword">public</span> T value;	<span class="comment">// 一般情况下，Datum的泛型为List&lt;Instance&gt;,前面的Map的key为Service的名称</span></span><br></pre></td></tr></table></figure>

<p>这些数据的关系描述：</p>
<ul>
<li>每个ServiceManager中保存了多个Namespace，不同Namespace下的Serivce可以重名</li>
<li>每个Namespace下保存了多个Service，即一个微服务</li>
<li>每个Service下保存了多个Cluster，例如北京的组成一个集群，深圳的组成一个集群</li>
<li>每个Cluster下保存了多个Instance，即多个微服务的实例</li>
<li>ServiceManager中还保存了一个对象ConsistencyService，该对象中保存了一个dataMap，即实例ID：实例，即所有的实例，用于同步数据。</li>
</ul>
<p>回到注册服务的Controller，registerInstance()代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String namespaceId, String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建空的service</span></span><br><span class="line">    createEmptyService(namespaceId, serviceName, instance.isEphemeral());</span><br><span class="line">	  <span class="comment">// 获取到创建的Service</span></span><br><span class="line">    Service service = getService(namespaceId, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NacosException(NacosException.INVALID_PARAM,</span><br><span class="line">                <span class="string">&quot;service not found, namespace: &quot;</span> + namespaceId + <span class="string">&quot;, service: &quot;</span> + serviceName);</span><br><span class="line">    &#125;</span><br><span class="line">	  <span class="comment">// 添加实例</span></span><br><span class="line">    addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registerInstance主要分为2部，即创建一个空的Service与向Service中添加实例</p>
<p><strong><font size="4px">createEmptyService</font></strong></p>
<p>创建空的Service(当Service不存在时才创建)，该方法主要会调用到createServiceIfAbsent：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serviceManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createServiceIfAbsent</span><span class="params">(String namespaceId, String serviceName, <span class="keyword">boolean</span> local, Cluster cluster)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    Service service = getService(namespaceId, serviceName);	<span class="comment">// 先看serviceMap中有没有该Service</span></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">			 <span class="comment">// 没有则创建Service</span></span><br><span class="line">        Loggers.SRV_LOG.info(<span class="string">&quot;creating empty service &#123;&#125;:&#123;&#125;&quot;</span>, namespaceId, serviceName);</span><br><span class="line">        service = <span class="keyword">new</span> Service();</span><br><span class="line">        service.setName(serviceName);</span><br><span class="line">        service.setNamespaceId(namespaceId);</span><br><span class="line">        service.setGroupName(NamingUtils.getGroupName(serviceName));</span><br><span class="line">        <span class="comment">// now validate the service. if failed, exception will be thrown</span></span><br><span class="line">        service.setLastModifiedMillis(System.currentTimeMillis());</span><br><span class="line">        service.recalculateChecksum();</span><br><span class="line">        <span class="keyword">if</span> (cluster != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cluster.setService(service);</span><br><span class="line">            service.getClusterMap().put(cluster.getName(), cluster);</span><br><span class="line">        &#125;</span><br><span class="line">        service.validate();</span><br><span class="line">			 <span class="comment">// 将Service存储到serviceMap中并且初始化</span></span><br><span class="line">        putServiceAndInit(service);</span><br><span class="line">        <span class="comment">// 持久化</span></span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            addOrReplaceService(service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来到putServiceAndInit中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serviceManager</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putServiceAndInit</span><span class="params">(Service service)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">    putService(service);		<span class="comment">// 向serviceMap中添加service</span></span><br><span class="line">    service.init();				  <span class="comment">// 初始化service</span></span><br><span class="line">    <span class="comment">// 同步器监听</span></span><br><span class="line">    consistencyService</span><br><span class="line">            .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">true</span>), service);</span><br><span class="line">    consistencyService</span><br><span class="line">            .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), <span class="keyword">false</span>), service);</span><br><span class="line">    Loggers.SRV_LOG.info(<span class="string">&quot;[NEW-SERVICE] &#123;&#125;&quot;</span>, service.toJson());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法先向serviceMap中添加了service，这部分比较简单，后续init了service，最后设置了consistencyService的监听，关于同步我们后续再说，看一看service的init()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向HealthCheck的执行器中提交检查健康的任务</span></span><br><span class="line">    HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class="line">    <span class="comment">// 把集群内保存的Service都设置为当前的Service，一般情况下刚刚创建的Service的clusterMap没有集群</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Cluster&gt; entry : clusterMap.entrySet()) &#123;</span><br><span class="line">        entry.getValue().setService(<span class="keyword">this</span>);</span><br><span class="line">        entry.getValue().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化主要是提交一个对服务进行健康检查的任务，每隔一段时间，都会检查该服务中所有实例是否定期上报健康心跳，如果没有心跳，则先保留一段时间，如果还未上报，则踢出。</p>
<p><strong><font size="4px">addInstance</font></strong></p>
<p>创建了空的Service后，就将注册的实例添加到Service中，如果原来就存在该Service，就直接添加实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serviceManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(String namespaceId, String serviceName, <span class="keyword">boolean</span> ephemeral, Instance... ips)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">	  <span class="comment">// 根据注册信息生成InastanceList的key，即保存一个Service中所有Instance的key，保存在consistencyService中</span></span><br><span class="line">    String key = KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);</span><br><span class="line"></span><br><span class="line">    Service service = getService(namespaceId, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (service) &#123;</span><br><span class="line">        <span class="comment">// 求得新加入Instance后的Instance列表</span></span><br><span class="line">        List&lt;Instance&gt; instanceList = addIpAddresses(service, ephemeral, ips);</span><br><span class="line"></span><br><span class="line">        Instances instances = <span class="keyword">new</span> Instances();</span><br><span class="line">        instances.setInstanceList(instanceList);</span><br><span class="line">			 </span><br><span class="line">        <span class="comment">// 将该服务对应的所有Insatance存储到consistencyService一份，并且通知serviceMap更新</span></span><br><span class="line">        consistencyService.put(key, instances);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要也是两部分，一个是更新Instance列表，另一个是将Instance列表存到consistencyService一份</p>
<p>首先看生成更新后Instance列表，即addIpAddresses方法，会调用到updateIpAddresses方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serviceManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Instance&gt; <span class="title">updateIpAddresses</span><span class="params">(Service service, String action, <span class="keyword">boolean</span> ephemeral, Instance... ips)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从consistencyService获取所有的Instance</span></span><br><span class="line">    Datum datum = consistencyService</span><br><span class="line">            .get(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), ephemeral));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从service中获取所有的Instance</span></span><br><span class="line">    List&lt;Instance&gt; currentIPs = service.allIPs(ephemeral);</span><br><span class="line">    Map&lt;String, Instance&gt; currentInstances = <span class="keyword">new</span> HashMap&lt;&gt;(currentIPs.size());</span><br><span class="line">    Set&lt;String&gt; currentInstanceIds = Sets.newHashSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝到一个临时的Map中</span></span><br><span class="line">    <span class="keyword">for</span> (Instance instance : currentIPs) &#123;</span><br><span class="line">        currentInstances.put(instance.toIpAddr(), instance);</span><br><span class="line">        currentInstanceIds.add(instance.getInstanceId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Instance&gt; instanceMap;</span><br><span class="line">    <span class="keyword">if</span> (datum != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新datum中所有实例的健康状态，并返回datum中的所有实例为instanceMap</span></span><br><span class="line">        instanceMap = setValid(((Instances) datum.value).getInstanceList(), currentInstances);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        instanceMap = <span class="keyword">new</span> HashMap&lt;&gt;(ips.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Instance instance : ips) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!service.getClusterMap().containsKey(instance.getClusterName())) &#123;</span><br><span class="line">            <span class="comment">// 如果没有service属于的集群就创建一个集群</span></span><br><span class="line">            Cluster cluster = <span class="keyword">new</span> Cluster(instance.getClusterName(), service);</span><br><span class="line">            cluster.init();</span><br><span class="line">            <span class="comment">// 将instance添加到集群中</span></span><br><span class="line">            service.getClusterMap().put(instance.getClusterName(), cluster);</span><br><span class="line">            Loggers.SRV_LOG</span><br><span class="line">                    .warn(<span class="string">&quot;cluster: &#123;&#125; not found, ip: &#123;&#125;, will create new cluster with default configuration.&quot;</span>,</span><br><span class="line">                            instance.getClusterName(), instance.toJson());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UtilsAndCommons.UPDATE_INSTANCE_ACTION_REMOVE.equals(action)) &#123;</span><br><span class="line">            instanceMap.remove(instance.getDatumKey());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 添加到临时的Map中</span></span><br><span class="line">            instance.setInstanceId(instance.generateInstanceId(currentInstanceIds));</span><br><span class="line">            instanceMap.put(instance.getDatumKey(), instance);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instanceMap.size() &lt;= <span class="number">0</span> &amp;&amp; UtilsAndCommons.UPDATE_INSTANCE_ACTION_ADD.equals(action)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">&quot;ip list can not be empty, service: &quot;</span> + service.getName() + <span class="string">&quot;, ip list: &quot;</span> + JacksonUtils</span><br><span class="line">                        .toJson(instanceMap.values()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回更新后的Instance列表，注意，此时还未更新service的cluster与consistencyService</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(instanceMap.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法返回了加入新的Instance后的所有Instance列表，它是基于consistencyService中存储的Instance为基准进行更新的，经过该方法，如果需要添加的Instance的集群是不存在的，则新建一个Cluster。</p>
<p>上述方法返回后，然后将更新后的Instance列表更新至各个map当中，addInstance中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consistencyService.put(key, instances);</span><br></pre></td></tr></table></figure>

<p>在一般的情况下，consistencyService为DistroConsistencyServiceImpl类的对象，该类是ConsistencyService的实现类，这个接口对于数据同步非常重要，后续再分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Record value)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">  onPut(key, value);</span><br><span class="line">  taskDispatcher.addTask(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPut</span><span class="params">(String key, Record value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将某个service的所有Instances更新到consistencyService的dataStore</span></span><br><span class="line">    <span class="keyword">if</span> (KeyBuilder.matchEphemeralInstanceListKey(key)) &#123;</span><br><span class="line">        Datum&lt;Instances&gt; datum = <span class="keyword">new</span> Datum&lt;&gt;();</span><br><span class="line">        datum.value = (Instances) value;</span><br><span class="line">        datum.key = key;</span><br><span class="line">        datum.timestamp.incrementAndGet();</span><br><span class="line">        dataStore.put(key, datum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断service对应的实例列表是否添加了监听，我们在前面createEmptyService中添加了监听</span></span><br><span class="line">    <span class="keyword">if</span> (!listeners.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加数据发生变化的事件</span></span><br><span class="line">    notifier.addTask(key, ApplyAction.CHANGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一方法主要是更新dataStore中的Instances列表，并且添加一个数据变化的事件到一个Queue中，在Nacos服务端会有线程不停的判断是否有事件，有事件就会取出去触发监听者，其中本地的serviceMap中的Cluster监听到该事件会同步数据到Cluster中的Instances集合中，即完成了服务注册的流程。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-10-29T10:16:35.000Z" title="2020-10-29T10:16:35.000Z">2020-10-29</time>发表</span><span class="level-item"><time dateTime="2020-10-30T01:08:14.169Z" title="2020-10-30T01:08:14.169Z">2020-10-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><span class="level-item">4 分钟读完 (大约563个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/29/Nacos%E6%BA%90%E7%A0%81-Nacos%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%BA%90%E7%A0%81%E5%90%AF%E5%8A%A8/">Nacos源码-Nacos服务端源码启动</a></h1><div class="content"><p>这些天准备阅读Nacos的源码，首先来搭建nacos源码的运行</p>
<h1 id="下载Nacos源码"><a href="#下载Nacos源码" class="headerlink" title="下载Nacos源码"></a>下载Nacos源码</h1><p>去github的<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos">nacos主页</a>下载1.3.1版本的nacos源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch 1.3.1 https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nacos.git</span><br></pre></td></tr></table></figure>

<p>或者到release下面直接下载对应的压缩包</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk68rt81clj318o0u014n.jpg" alt="image-20201029153608508" style="zoom: 50%;" />





<h1 id="使用IDEA导入项目"><a href="#使用IDEA导入项目" class="headerlink" title="使用IDEA导入项目"></a>使用IDEA导入项目</h1><p>我们直接使用IDEA打开下载下来的文件夹，则可以看到Nacos的项目目录</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk68v1nvowj30q218e0xo.jpg" alt="image-20201029153917599" style="zoom: 33%;" />



<h1 id="启动Nacos"><a href="#启动Nacos" class="headerlink" title="启动Nacos"></a>启动Nacos</h1><p>进入nacos项目的console模块，是nacos的控制台模块，该项目是一个Springboot项目，启动该模块即可启动nacos所有的功能。</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk68yr5y3zj30ok0r0tbg.jpg" alt="image-20201029154251731" style="zoom:50%;" />

<p>在启动前，给Nacos类的main添加JVM参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dnacos.standalone=true</span><br></pre></td></tr></table></figure>

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk690lly9xj31bj0u0q8z.jpg" alt="image-20201029154437702" style="zoom:50%;" />

<p>启动main即可启动nacos，在浏览器中键入<code>localhost:8848/nacos</code>来到Nacos的登录页面，默认情况下登录的用户名和密码都是nacos，登录后可以看到如下界面：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk693az3rpj32v40skjwi.jpg" alt="image-20201029154713893"></p>
<h1 id="Nacos集群启动"><a href="#Nacos集群启动" class="headerlink" title="Nacos集群启动"></a>Nacos集群启动</h1><h2 id="配置Mysql"><a href="#配置Mysql" class="headerlink" title="配置Mysql"></a>配置Mysql</h2><ul>
<li>Nacos版本：1.3.1</li>
<li>Mysql版本：8.0.19</li>
</ul>
<p>首先将项目最外层的<code>pom.xml</code>的mysql版本从8.0.16改为8.0.19</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk6be518bbj31z00j4q9s.jpg" alt="image-20201029170650514"></p>
<p><strong>创建数据库：</strong></p>
<p>在distribution模块下的conf目录中找到<code>nacos-mysql.sql</code>，在本地数据库执行生成数据库表</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk6biraqxij30i00ks45w.jpg" alt="image-20201029171116675" style="zoom:50%;" />



<p><strong>配置数据源：</strong></p>
<p>在console模块下的<code>application.properties</code>的配置文件中添加：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">1				# 数据库编号，可以配置多个数据库</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://192.168.100.164:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p>这样配置后，Nacos将使用mysql数据库来进行数据的持久化。</p>
<p><strong>更改配置文件：</strong></p>
<p>找到distribution模块的conf目录，添加<code>cluster.conf</code>文件或者把<code>cluster.conf.example</code>改为<code>cluster.conf</code>，该文件是配置Nacos集群各个集群的ip地址，编辑内容为如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#2020-10-29T17:04:22.196</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.100</span><span class="number">.164</span>:<span class="number">8848</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.100</span><span class="number">.164</span>:<span class="number">8849</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.100</span><span class="number">.164</span>:<span class="number">8850</span></span><br></pre></td></tr></table></figure>



<p><strong>添加启动参数：</strong></p>
<p>在nacos的console模块下的启动类上添加启动参数，即Nacos类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dnacos.home=/Volumes/data/Java/sourcecode/nacos-<span class="number">1.3</span>.<span class="number">1</span>/distribution</span><br></pre></td></tr></table></figure>

<p>配置该参数的目的是在项目启动时，会去找到该目录下刚刚编写的conf文件。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk6bthl7ijj318e0u0454.jpg" alt="image-20201029172135544"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-10-20T09:11:02.000Z" title="2020-10-20T09:11:02.000Z">2020-10-20</time>发表</span><span class="level-item"><time dateTime="2020-10-31T07:14:48.283Z" title="2020-10-31T07:14:48.283Z">2020-10-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><span class="level-item">9 分钟读完 (大约1305个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/20/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">docker常用命令</a></h1><div class="content"><h1 id="docker-run启动"><a href="#docker-run启动" class="headerlink" title="docker run启动"></a>docker run启动</h1><p><code>docker run [option] 镜像名 [向启动容器中传入的命令]</code></p>
<ul>
<li>-i 表示以“交互模式”运行容器</li>
<li>-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</li>
<li>–name 为创建的容器命名。<code>--name=&quot;nginx-lb&quot;</code></li>
<li>-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 <code>宿主机目录:容器中目录</code>)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后共享到容器上。 <code>-v /data/mysql:/mysql /data/redis:/redis</code></li>
<li>-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不会自动登录容器，即后台运行。如果只加-i -t 两个参数，创建后就会自动进去容器)。</li>
<li>-p 表示端口映射，<code>宿主机端口:容器内的映射端口</code>。可以使用多个-p 做多个端口映射。<code>-p 26888:80 26889:8080</code></li>
<li>-P 随机端口映射，一般在dockerfile中有暴露端口</li>
<li>-e 为容器设置环境变量</li>
<li>–net 表示使用的网络配置，可以自动以网络配置。<code>--net bridge</code>是默认加上的</li>
<li>–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同</li>
<li>-m :设置容器使用内存最大值；<code>-m 512M</code> or <code>-m 4G</code></li>
<li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li>
<li>-c,–cpu-shares=0    # CPU 共享权值（相对权重）</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run </span><br><span class="line">    -p <span class="number">26881</span>:<span class="number">3306</span> 	<span class="comment">// 主机端口26881映射到容器的3306端口</span></span><br><span class="line">    -v /project/p1/mysql/data:/mysql/data 	<span class="comment">// 主机的/project/p1/mysql/data与容器的/mysql/data共享卷</span></span><br><span class="line">    --name <span class="string">&quot;mysql&quot;</span> 		<span class="comment">// 容器名称mysql</span></span><br><span class="line">    --cpuset=<span class="string">&quot;0-2&quot;</span>		<span class="comment">// 给该容器分配CPU0,1,2</span></span><br><span class="line">    -m <span class="number">10</span>G			    <span class="comment">// 该容器最大的使用内存10G</span></span><br><span class="line">    -d 				    <span class="comment">// 后台启动</span></span><br><span class="line">    mysql:<span class="number">8.0</span>.<span class="number">19</span>		<span class="comment">// 启动mysql:8.0.19镜像</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v ~/application/docker/volumn/java-centos:/docker/volumn --name <span class="string">&quot;java-centos&quot;</span> -i -t centos:<span class="number">7</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p -v ~/application/docker/volumn/jdk1.<span class="number">8</span>-centos:/docker/volumn --name <span class="string">&quot;jdk1.8-centos&quot;</span> -i -t centos:<span class="number">7</span></span><br></pre></td></tr></table></figure>



<h1 id="进入docker容器"><a href="#进入docker容器" class="headerlink" title="进入docker容器"></a>进入docker容器</h1><p><strong>docker attach</strong></p>
<p><code>sudo docker attach [容器id] </code></p>
<p><strong>docker exec</strong></p>
<p><code>sudo docker exec -it [容器id] /bin/bash</code></p>
<h1 id="将容器变为镜像"><a href="#将容器变为镜像" class="headerlink" title="将容器变为镜像"></a>将容器变为镜像</h1><p><code>docker commit -m=&quot;描述&quot; -a=&quot;作者&quot; [容器Id] [镜像名]:[标签名]</code></p>
<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="docker网络原理"><a href="#docker网络原理" class="headerlink" title="docker网络原理"></a>docker网络原理</h2><p>默认情况下，docker各个容器之间采用桥接模式</p>
<p><strong>docker主机查看网络配置：</strong></p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gjyilaidiaj31cw0os461.jpg" alt="image-20201022230958846" style="zoom:50%;" />

<p><strong>容器1的网络配置：</strong></p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gjyiztg28pj31ge0b00vx.jpg" alt="image-20201022232518581" style="zoom:50%;" />

<p><strong>容器2的网络配置：</strong></p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gjyj2x8mloj31f40aigot.jpg" alt="image-20201022232736594" style="zoom:50%;" />



<p><strong>启动两个docker容器后主机的网络配置：</strong></p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gjyj8hjue6j316s0u0aks.jpg" alt="image-20201022233327602" style="zoom:50%;" />



<p>默认情况下网络关系如下：</p>
<ul>
<li>主机可以直接ping通两个容器</li>
<li>两个容器也可以直接ping通主机</li>
<li>两个容器之间直接能ping通</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gjyjl3x4doj31aj0u0aej.jpg" alt="image-20201022234512297" style="zoom:50%;" />



<p><code>docker network ls</code>：查看当前所有的docker网卡</p>
<p><code>docker network inspect [网卡ID]</code>：查看某个网卡的详细信息</p>
<h2 id="docker容器之间的通信"><a href="#docker容器之间的通信" class="headerlink" title="docker容器之间的通信"></a>docker容器之间的通信</h2><p>在默认的docker0网络配置下，dokcer容器之间可以通过ip来ping通，但是无法通过容器名来进行ping通，一种方式使用过在启动时<code>--link [容器名]</code>来指定该容器需要通信的容器名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name centos01 java-centos:<span class="number">7</span></span><br><span class="line">docker run --name centos02 --link centos01 java-centos:<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>这样启动后，centos02可以ping通centos01，但是centos01不能ping通centos02，<code>--link</code>会存在很多坑，它是直接往容器的host目录下写一个DNS来实现通过容器名访问其他容器的，而且这样非常不方便，官方已经不推荐使用。</p>
<p>想要通过容器名来ping通，最好的方式就是通过自定义网络来实现，通过<code>docker network ls</code>可以看到：</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gjz0kj1vcuj30xc04igmg.jpg" alt="image-20201023093326317" style="zoom:50%;" />

<p>默认的都是采用bridge的网络，即docker0。</p>
<p>我们可以自定义一个网络：</p>
<p><code>docker network create --driver [驱动方式] --subnect [内网ip网络划分] --gateway [内网网卡] [网络名称]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge --subnet <span class="number">196.168</span>.<span class="number">0.0</span>/<span class="number">16</span> --gateway <span class="number">196.168</span>.<span class="number">0.1</span> mynet</span><br><span class="line"><span class="comment">// --driver bridge表示桥接的方式，不指定的话默认也是桥接，一般都用桥接</span></span><br><span class="line"><span class="comment">// --subnet 196.168.0.0/16 表示内网地址为196.168.x.x，16表示子网划分，后面16位都是内网支持的，因此可以分配65535个ip</span></span><br><span class="line"><span class="comment">// --gateway 196.168.0.1 表示网关的ip地址，即路由器地址</span></span><br></pre></td></tr></table></figure>

<p>我们使用自定义的网络来启动容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=<span class="string">&quot;centos02&quot;</span> -it --net mynet jdk:<span class="number">1.8</span></span><br><span class="line">docker run --name=<span class="string">&quot;centos01&quot;</span> -it --net mynet jdk:<span class="number">1.8</span></span><br></pre></td></tr></table></figure>

<p>此时两个容器之间就可以直接通过容器名来ping通了</p>
<p><strong>不同网络配置下的容器相互通信</strong></p>
<p>加入现在centos01容器是在docker0的网络配置下启动的，而centos02容器是在mynet的网络配置下启动的，那么此时无论的是通过ping ip还是ping 容器名都是无法ping通的，向要centos01与centos02能够ping通只需要将centos01加入到mynet下即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect mynet centos01</span><br></pre></td></tr></table></figure>

<p>这样一来在mynet下就给centos01分配了一个ip地址，即一个容器有多个ip地址，那么centos01与mynet下的所有容器都互通了</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-30T13:49:53.000Z" title="2020-09-30T13:49:53.000Z">2020-09-30</time>发表</span><span class="level-item"><time dateTime="2020-10-01T14:03:13.000Z" title="2020-10-01T14:03:13.000Z">2020-10-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></span><span class="level-item">18 分钟读完 (大约2754个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/30/Java%E5%B9%B6%E5%8F%91-ThreadLocal/">Java并发-ThreadLocal</a></h1><div class="content"><p>ThreadLocal在Java中应用非常之多，ThreadLocal用于保存与线程绑定的对象，即一个对象通过ThreadLocal与线程进行绑定后，我们在任意的方法中，都能获取到线程所绑定的对象。</div><a class="article-more button is-small size-small" href="/2020/09/30/Java%E5%B9%B6%E5%8F%91-ThreadLocal/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-17T02:48:28.000Z" title="2020-09-17T02:48:28.000Z">2020-09-17</time>发表</span><span class="level-item"><time dateTime="2020-09-17T02:55:43.000Z" title="2020-09-17T02:55:43.000Z">2020-09-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></span><span class="level-item">24 分钟读完 (大约3586个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/17/CAS%E4%B9%8BLongAdder/">CAS之LongAdder</a></h1><div class="content"><p>从JDK1.8开始，有提供了针对Long类型的原子累加器，为LongAdder与LongAccumulator，也针对Double类型的原子累加器，为DoubleAdder与DoubleAccumulator。jdk底层对DoubleAdder的实现是基于LongAdder的，因为两者都是占2个字节的变量。在此就以LongAdder为例。</div><a class="article-more button is-small size-small" href="/2020/09/17/CAS%E4%B9%8BLongAdder/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-11T02:50:12.000Z" title="2020-09-11T02:50:12.000Z">2020-09-11</time>发表</span><span class="level-item"><time dateTime="2020-09-13T02:18:42.000Z" title="2020-09-13T02:18:42.000Z">2020-09-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></span><span class="level-item">1 小时读完 (大约7384个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/">Java并发-volatile</a></h1><div class="content"><p>volatile在多线程编程中是使用非常之多的一个关键字，对内存的可见性与指令的有序性加以控制，它是保证多线程工作安全、可控的一把利器。</div><a class="article-more button is-small size-small" href="/2020/09/11/Java%E5%B9%B6%E5%8F%91-volatile/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-10T09:07:11.000Z" title="2020-09-10T09:07:11.000Z">2020-09-10</time>发表</span><span class="level-item"><time dateTime="2020-09-10T09:07:18.000Z" title="2020-09-10T09:07:18.000Z">2020-09-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Netty/">Netty</a></span><span class="level-item">29 分钟读完 (大约4335个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/">Netty核心组件-EventLoop与BootStrap</a></h1><div class="content"><p>上一次我们讲到了EventLoopGroup，EventLoop的初始化跳过了，现在来深入研究EventLoop组件，EventLoop是Netty非常重要的组件，它是网络请求处理的核心，通过Selector不断循环监听Channel的事件，处理相应的请求。</div><a class="article-more button is-small size-small" href="/2020/09/10/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop%E4%B8%8EBootStrap/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-09T08:43:51.000Z" title="2020-09-09T08:43:51.000Z">2020-09-09</time>发表</span><span class="level-item"><time dateTime="2020-09-10T01:23:54.000Z" title="2020-09-10T01:23:54.000Z">2020-09-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Netty/">Netty</a></span><span class="level-item">25 分钟读完 (大约3747个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/09/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoopGroup/">Netty核心组件-EventLoopGroup</a></h1><div class="content"><p>Netty高性能架构–线程模型：Netty之所以性能很高，除了依赖于Nio的特性外，还实现了一套高效的线程模型。</div><a class="article-more button is-small size-small" href="/2020/09/09/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoopGroup/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-08T07:57:22.000Z" title="2020-09-08T07:57:22.000Z">2020-09-08</time>发表</span><span class="level-item"><time dateTime="2020-09-08T11:18:15.000Z" title="2020-09-08T11:18:15.000Z">2020-09-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Netty/">Netty</a></span><span class="level-item">20 分钟读完 (大约3042个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/08/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ChannelFuture/">Netty核心组件-ChannelFuture</a></h1><div class="content"><p>Netty的特点就是异步非阻塞的网络框架，在Netty中，几乎所有的IO操作都是异步执行的，我们调用IO操作的方法后，方法会返回一个Future类型的对象(一般为ChannelFuture)，ChannelFuture继承于JDK的Future对象，对Future进行了扩充。</div><a class="article-more button is-small size-small" href="/2020/09/08/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ChannelFuture/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-01T12:17:51.000Z" title="2020-09-01T12:17:51.000Z">2020-09-01</time>发表</span><span class="level-item"><time dateTime="2020-09-09T02:01:19.000Z" title="2020-09-09T02:01:19.000Z">2020-09-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Netty/">Netty</a></span><span class="level-item">16 分钟读完 (大约2403个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/01/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ByteBuf/">Netty核心组件-ByteBuf</a></h1><div class="content"><p>JDK提供的Buffer类实在太难用，例如读写操作切换需要<code>flip()</code>，DirectByteBuffer使用起来不方便。因此Netty自己提供了一套缓冲区的ByteBuf类来方便的进行缓冲区操作，在功能上与NIO的ByteBuffer是相同的。</div><a class="article-more button is-small size-small" href="/2020/09/01/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-ByteBuf/#more">阅读更多</a></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://gitee.com/leizz1/pictures/raw/master/null/AF32230B-6341-40A5-BADE-7C898E5E858B(20190701-101.JPG" alt="tomcode"></figure><p class="title is-size-4 is-block line-height-inherit">tomcode</p><p class="is-size-6 is-block">努力努力再努力</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">19</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MrZhangL" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/JAVA/"><span class="level-start"><span class="level-item">JAVA</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="level-start"><span class="level-item">Java多线程</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Netty/"><span class="level-start"><span class="level-item">Netty</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SSM/"><span class="level-start"><span class="level-item">SSM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-30T13:51:55.000Z">2020-10-30</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/30/Nacos%E6%BA%90%E7%A0%81-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B/">Nacos源码-服务注册流程</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-29T10:16:35.000Z">2020-10-29</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/29/Nacos%E6%BA%90%E7%A0%81-Nacos%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%BA%90%E7%A0%81%E5%90%AF%E5%8A%A8/">Nacos源码-Nacos服务端源码启动</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-20T09:11:02.000Z">2020-10-20</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/20/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">docker常用命令</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-30T13:49:53.000Z">2020-09-30</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/30/Java%E5%B9%B6%E5%8F%91-ThreadLocal/">Java并发-ThreadLocal</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-17T02:48:28.000Z">2020-09-17</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/17/CAS%E4%B9%8BLongAdder/">CAS之LongAdder</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nacos/"><span class="tag">nacos</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/netty/"><span class="tag">netty</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">3</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="MrZhang" height="28"></a><p class="size-small"><span>&copy; 2020 tomcode</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/MrZhangL"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>